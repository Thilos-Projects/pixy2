; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\serial.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\serial.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IE:\Keil\Pack\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IE:\Keil\Pack\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\serial.crf src\serial.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Z13ser_getSerialv PROC ; ser_getSerial()
;;;798    
;;;799    Iserial *ser_getSerial()
000000  48f8              LDR      r0,|L1.996|
;;;800    {
;;;801    	return g_serial;
000002  69c0              LDR      r0,[r0,#0x1c]  ; g_serial
;;;802    }
000004  4770              BX       lr
                          ENDP

                  _Z12lego_getDataPhj PROC ; lego_getData(unsigned char*, unsigned)
;;;66     
;;;67     uint16_t lego_getData(uint8_t *buf, uint32_t buflen)
000006  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;68     {
00000a  b08d              SUB      sp,sp,#0x34
00000c  4604              MOV      r4,r0
;;;69     	static uint16_t lastReverse = 0xffff;
;;;70     	static uint8_t lastLamp = 0;
;;;71     	uint8_t c, reverse, lamp;
;;;72     	uint16_t d, x, y;
;;;73     	bool sat;
;;;74     	int8_t turn;
;;;75     	int16_t turn16;
;;;76     	uint16_t numBlobs;
;;;77     	uint32_t temp, width, height, r, g, b;
;;;78     	Iserial *serial = ser_getSerial();
00000e  f7fffffe          BL       _Z13ser_getSerialv ; ser_getSerial()
000012  4606              MOV      r6,r0
;;;79     	bool error = false;
000014  2500              MOVS     r5,#0
;;;80     	static int8_t ccc = -1;
;;;81     	static int8_t line = -1;
;;;82     	static int8_t video = -1;
;;;83     	
;;;84     	if (serial->receive(&c, 1)==0)
000016  6830              LDR      r0,[r6,#0]
000018  2201              MOVS     r2,#1
00001a  a90c              ADD      r1,sp,#0x30
00001c  6883              LDR      r3,[r0,#8]
00001e  4630              MOV      r0,r6
000020  4798              BLX      r3
000022  b1c0              CBZ      r0,|L1.86|
;;;85     		return 0;
;;;86     
;;;87     	if (c>=0x50 && c<=0x59)
000024  f89d0030          LDRB     r0,[sp,#0x30]
;;;88     	{
;;;89     		if (ccc<0)
000028  4fee              LDR      r7,|L1.996|
00002a  f1a00150          SUB      r1,r0,#0x50           ;87
00002e  2909              CMP      r1,#9                 ;87
000030  d817              BHI      |L1.98|
000032  f9970007          LDRSB    r0,[r7,#7]  ; ccc
000036  2800              CMP      r0,#0
000038  da04              BGE      |L1.68|
;;;90     			ccc = exec_getProgIndex("color_connected_components");
00003a  2100              MOVS     r1,#0
00003c  a0ea              ADR      r0,|L1.1000|
00003e  f7fffffe          BL       _Z17exec_getProgIndexPKcP5Chirp ; exec_getProgIndex(const char*, Chirp*)
000042  71f8              STRB     r0,[r7,#7]
                  |L1.68|
;;;91     		error = exec_setProgIndex(ccc)!=ccc;
000044  79f8              LDRB     r0,[r7,#7]  ; ccc
000046  f7fffffe          BL       _Z17exec_setProgIndexh ; exec_setProgIndex(unsigned char)
00004a  f9971007          LDRSB    r1,[r7,#7]  ; ccc
00004e  4288              CMP      r0,r1
000050  d005              BEQ      |L1.94|
000052  2501              MOVS     r5,#1
000054  e032              B        |L1.188|
                  |L1.86|
000056  2000              MOVS     r0,#0                 ;85
                  |L1.88|
;;;92     	}
;;;93     	else if (c>=0x5a && c<=0x5d)
;;;94     	{
;;;95     		if (line<0)
;;;96     			line = exec_getProgIndex("line_tracking");
;;;97     		error = exec_setProgIndex(line)!=line;
;;;98     	}
;;;99     	else if (c==0x5e)
;;;100    	{
;;;101    		if (video<0)
;;;102    			video = exec_getProgIndex("video");
;;;103    		error = exec_setProgIndex(video)!=video;
;;;104    	}
;;;105    	
;;;106    		
;;;107    #if 1
;;;108    	if (c==0x00)
;;;109    	{
;;;110    		const char *str = "V0.4";
;;;111    		strcpy((char *)buf, str);
;;;112    		return 5;
;;;113    	}
;;;114    	if (c==0x08)
;;;115    	{
;;;116    		const char *str = "Pixy2";
;;;117    		strcpy((char *)buf, str);
;;;118    		return 6;
;;;119    	}
;;;120    	else if (c==0x10)
;;;121    	{
;;;122    		const char *str = "Pixy2";
;;;123    		strcpy((char *)buf, str);
;;;124    		return 6;		
;;;125    	}
;;;126    	else 
;;;127    #endif
;;;128    	if (c==0x50)
;;;129    	{
;;;130    		BlobA *max;
;;;131    #if 0
;;;132    		buf[0] = 1;
;;;133    		buf[1] = 2;
;;;134    		buf[2] = 3;
;;;135    		buf[3] = 4;
;;;136    		buf[4] = 5;
;;;137    		buf[5] = 6;
;;;138    		buf[6] = 7;
;;;139    #else
;;;140    		max = (BlobA *)g_blobs->getMaxBlob();
;;;141    		if (max==0)
;;;142    			memset(buf, 0, 7);
;;;143    		else if (max==(BlobA *)-1 || error)
;;;144    			memset(buf, -1, 7);
;;;145    		else
;;;146    		{
;;;147    			width = max->m_right - max->m_left;
;;;148    			height = max->m_bottom - max->m_top;
;;;149    			*(uint16_t *)buf = max->m_model; // signature
;;;150    			temp = ((max->m_left + width/2)*829)>>10;
;;;151    			buf[2] = temp; // x
;;;152    			temp = ((max->m_top + height/2)*1262)>>10;
;;;153    			buf[3] = temp; // y
;;;154    			temp = (width*829)>>10;
;;;155    			buf[4] = temp; // width
;;;156    			temp = (height*1262)>>10;
;;;157    			buf[5] = temp; // height
;;;158    			if (max->m_model>CL_NUM_SIGNATURES)
;;;159    			{
;;;160    				temp = ((int32_t)max->m_angle*91)>>7;
;;;161    				g_angle = temp;
;;;162    			}
;;;163    		}
;;;164    #endif		
;;;165    		return 6;
;;;166    	}
;;;167    	else if (c==0x60)
;;;168    	{
;;;169    		buf[0] = g_angle;
;;;170    		return 1;
;;;171    	}
;;;172    	else if (c>=0x51 && c<=0x57)
;;;173    	{
;;;174    #if 0
;;;175    		buf[0] = 1;
;;;176    		buf[1] = 2;
;;;177    		buf[2] = 3;
;;;178    		buf[3] = 4;
;;;179    		buf[4] = 5;
;;;180    #else
;;;181    		BlobA *max;
;;;182    		max = g_blobs->getMaxBlob(c-0x50, &numBlobs);
;;;183    		if (max==0)
;;;184    			memset(buf, 0, 5);
;;;185    		else if (max==(BlobA *)-1 || error)
;;;186    			memset(buf, -1, 5);
;;;187    		else
;;;188    		{
;;;189    			width = max->m_right - max->m_left;
;;;190    			height = max->m_bottom - max->m_top;
;;;191    			buf[0] = numBlobs; // number of blocks that match signature
;;;192    			temp = ((max->m_left + width/2)*829)>>10;
;;;193    			buf[1] = temp; // x
;;;194    			temp = ((max->m_top + height/2)*1262)>>10;
;;;195    			buf[2] = temp;	// y
;;;196    			temp = (width*829)>>10;
;;;197    			buf[3] = temp; // width
;;;198    			temp = (height*1262)>>10;
;;;199    			buf[4] = temp; // height
;;;200    		}
;;;201    #endif
;;;202    		return 5;
;;;203    	}
;;;204    	else if (c==0x58)
;;;205    	{
;;;206    		BlobA *max;
;;;207    		if (serial->receive((uint8_t *)&d, 2)<2) // receive cc signature to look for
;;;208    			return 0;
;;;209    #if 0
;;;210    		buf[0] = 1;
;;;211    		buf[1] = 2;
;;;212    		buf[2] = 3;
;;;213    		buf[3] = 4;
;;;214    		buf[4] = 5;
;;;215    		buf[5] = 6;
;;;216    #else
;;;217    		max = (BlobA *)g_blobs->getMaxBlob(d, &numBlobs); 
;;;218    		if (max==0)
;;;219    			memset(buf, 0, 6);
;;;220    		else if (max==(BlobA *)-1 || error)
;;;221    			memset(buf, -1, 6);
;;;222    		else
;;;223    		{
;;;224    			width = max->m_right - max->m_left;
;;;225    			height = max->m_bottom - max->m_top;
;;;226    			buf[0] = numBlobs; // number of cc blocks that match 
;;;227    			temp = ((max->m_left + width/2)*829)>>10;
;;;228    			buf[1] = temp; // x
;;;229    			temp = ((max->m_top + height/2)*1262)>>10;
;;;230    			buf[2] = temp; // y
;;;231    			temp = (width*829)>>10;
;;;232    			buf[3] = temp; // width
;;;233    			temp = (height*1262)>>10;
;;;234    			buf[4] = temp; // height
;;;235    			temp = ((int32_t)max->m_angle*91)>>7;
;;;236    			buf[5] = temp; // angle
;;;237    		}
;;;238    #endif
;;;239    		return 6;
;;;240    	}
;;;241    	else if (c==0x5a)
;;;242    	{
;;;243    		if (serial->receive((uint8_t *)&turn, 1)==1 && 
;;;244    			serial->receive((uint8_t *)&reverse, 1)==1 &&
;;;245    			serial->receive((uint8_t *)&lamp, 1)==1 &&
;;;246    			error==false)
;;;247    		{
;;;248    			turn16 = turn;
;;;249    			turn16 *= 180; // scale accordingly
;;;250    			turn16 /= 127;
;;;251    			line_setNextTurnAngle(turn16);
;;;252    			if (lastReverse!=0xffff && lastReverse!=reverse)
;;;253    				line_reversePrimary();
;;;254    			if (lastLamp!=lamp)
;;;255    			{
;;;256    				if (lamp)
;;;257    					led_setLamp(0xff, 0xff);
;;;258    				else
;;;259    					led_setLamp(0, 0);
;;;260    			}
;;;261    			
;;;262    			lastReverse = reverse;
;;;263    			lastLamp = lamp;
;;;264    			return line_legoLineData(buf, buflen);
;;;265    			}
;;;266    		else 
;;;267    		{
;;;268    			memset(buf, -1, 4);
;;;269    			return 4;
;;;270    		}
;;;271    	}
;;;272    	else if (c==0x5e) // get RGB
;;;273    	{
;;;274    		if (serial->receive(buf, 3)==3 && 
;;;275    			error==false)
;;;276    		{
;;;277    			x = buf[0]*(CAM_RES2_WIDTH-1)/255;
;;;278    			y = buf[1]*(CAM_RES2_HEIGHT-1)/255;
;;;279    			sat = buf[2];
;;;280    			temp = getRGB(x, y, sat);
;;;281    			rgbUnpack(temp, &r, &g, &b);
;;;282    			buf[0] = r;
;;;283    			buf[1] = g;
;;;284    			buf[2] = b;
;;;285    			return 3;
;;;286    		}
;;;287    		else
;;;288    		{
;;;289    			memset(buf, -1, 3);
;;;290    			return 3;
;;;291    		}
;;;292    	}
;;;293    	else if (c==0x62)
;;;294    	{
;;;295    		if (serial->receive((uint8_t *)&lamp, 1)==1 && 
;;;296    			error==false)
;;;297    			{
;;;298    				if (exec_getProg(ccc)==true)
;;;299    					led_setLamp(lamp ? 0xff : 0, 0);
;;;300    				else if (lamp)
;;;301    					led_setLamp(0xff, 0xff);
;;;302    				else
;;;303    					led_setLamp(0, 0);
;;;304    			}
;;;305    		buf[0] = 1;	
;;;306    		return 1;
;;;307    	}
;;;308    	else  
;;;309    	{
;;;310    #if 0
;;;311    		static uint8_t c = 0;
;;;312    
;;;313    		buf[0] = c++;
;;;314    #else
;;;315    		//printf("%x\n", c);														  
;;;316    
;;;317    		if (c==0x42) // this works in port view mode on the ev3's LCD
;;;318    		{
;;;319    			BlobA *max;
;;;320    			max = g_blobs->getMaxBlob();
;;;321    			if (max==0 || max==(BlobA *)-1)
;;;322    				buf[0] = 0;
;;;323    			else
;;;324    			{
;;;325    				width = max->m_right - max->m_left;
;;;326    				temp = ((max->m_left + width/2)*829)>>10;
;;;327    				buf[0] = temp;
;;;328    			}
;;;329    		}
;;;330    		else
;;;331    			buf[0] = 1;	 // need to return nonzero value for other inquiries or LEGO brick will think we're an analog sensor
;;;332    
;;;333    #endif
;;;334    		return 1;
;;;335    	}
;;;336    }
000058  b00f              ADD      sp,sp,#0x3c
00005a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.94|
00005e  2500              MOVS     r5,#0                 ;91
000060  e02c              B        |L1.188|
                  |L1.98|
000062  f1a0015a          SUB      r1,r0,#0x5a           ;93
000066  2903              CMP      r1,#3                 ;93
000068  d813              BHI      |L1.146|
00006a  f9970008          LDRSB    r0,[r7,#8]            ;95  ; line
00006e  2800              CMP      r0,#0                 ;95
000070  da04              BGE      |L1.124|
000072  2100              MOVS     r1,#0                 ;96
000074  a0e3              ADR      r0,|L1.1028|
000076  f7fffffe          BL       _Z17exec_getProgIndexPKcP5Chirp ; exec_getProgIndex(const char*, Chirp*)
00007a  7238              STRB     r0,[r7,#8]            ;96
                  |L1.124|
00007c  7a38              LDRB     r0,[r7,#8]            ;97  ; line
00007e  f7fffffe          BL       _Z17exec_setProgIndexh ; exec_setProgIndex(unsigned char)
000082  f9971008          LDRSB    r1,[r7,#8]            ;97  ; line
000086  4288              CMP      r0,r1                 ;97
000088  d001              BEQ      |L1.142|
00008a  2501              MOVS     r5,#1                 ;97
00008c  e016              B        |L1.188|
                  |L1.142|
00008e  2500              MOVS     r5,#0                 ;97
000090  e014              B        |L1.188|
                  |L1.146|
000092  285e              CMP      r0,#0x5e              ;99
000094  d112              BNE      |L1.188|
000096  f9970009          LDRSB    r0,[r7,#9]            ;101  ; video
00009a  2800              CMP      r0,#0                 ;101
00009c  da04              BGE      |L1.168|
00009e  2100              MOVS     r1,#0                 ;102
0000a0  a0dc              ADR      r0,|L1.1044|
0000a2  f7fffffe          BL       _Z17exec_getProgIndexPKcP5Chirp ; exec_getProgIndex(const char*, Chirp*)
0000a6  7278              STRB     r0,[r7,#9]            ;102
                  |L1.168|
0000a8  7a78              LDRB     r0,[r7,#9]            ;103  ; video
0000aa  f7fffffe          BL       _Z17exec_setProgIndexh ; exec_setProgIndex(unsigned char)
0000ae  f9971009          LDRSB    r1,[r7,#9]            ;103  ; video
0000b2  4288              CMP      r0,r1                 ;103
0000b4  d001              BEQ      |L1.186|
0000b6  2501              MOVS     r5,#1                 ;103
0000b8  e000              B        |L1.188|
                  |L1.186|
0000ba  2500              MOVS     r5,#0                 ;103
                  |L1.188|
0000bc  f89d0030          LDRB     r0,[sp,#0x30]         ;108
0000c0  b320              CBZ      r0,|L1.268|
0000c2  2808              CMP      r0,#8                 ;114
0000c4  d028              BEQ      |L1.280|
0000c6  2810              CMP      r0,#0x10              ;120
0000c8  d02c              BEQ      |L1.292|
0000ca  f8df9350          LDR      r9,|L1.1052|
0000ce  f04f0800          MOV      r8,#0                 ;128
0000d2  f04f3bff          MOV      r11,#0xffffffff       ;143
0000d6  2850              CMP      r0,#0x50              ;128
0000d8  d02a              BEQ      |L1.304|
0000da  2860              CMP      r0,#0x60              ;167
0000dc  d06b              BEQ      |L1.438|
0000de  f1a00151          SUB      r1,r0,#0x51           ;172
0000e2  2906              CMP      r1,#6                 ;172
0000e4  d870              BHI      |L1.456|
0000e6  3850              SUBS     r0,r0,#0x50           ;182
0000e8  b281              UXTH     r1,r0                 ;182
0000ea  aa07              ADD      r2,sp,#0x1c           ;182
0000ec  f8d90000          LDR      r0,[r9,#0]            ;182  ; g_blobs
0000f0  f7fffffe          BL       _ZN5Blobs10getMaxBlobEtPt ; Blobs::getMaxBlob(unsigned short, unsigned short*)
0000f4  2800              CMP      r0,#0                 ;183
0000f6  d062              BEQ      |L1.446|
0000f8  1c41              ADDS     r1,r0,#1              ;185
0000fa  d001              BEQ      |L1.256|
0000fc  2d00              CMP      r5,#0                 ;185
0000fe  d064              BEQ      |L1.458|
                  |L1.256|
000100  465a              MOV      r2,r11                ;186
000102  2105              MOVS     r1,#5                 ;186
000104  4620              MOV      r0,r4                 ;186
000106  f7fffffe          BL       __aeabi_memset
00010a  e07f              B        |L1.524|
                  |L1.268|
00010c  a1c4              ADR      r1,|L1.1056|
00010e  4620              MOV      r0,r4                 ;111
000110  f7fffffe          BL       strcpy
000114  2005              MOVS     r0,#5                 ;112
000116  e79f              B        |L1.88|
                  |L1.280|
000118  a1c3              ADR      r1,|L1.1064|
00011a  4620              MOV      r0,r4                 ;117
00011c  f7fffffe          BL       strcpy
000120  2006              MOVS     r0,#6                 ;118
000122  e799              B        |L1.88|
                  |L1.292|
000124  a1c0              ADR      r1,|L1.1064|
000126  4620              MOV      r0,r4                 ;123
000128  f7fffffe          BL       strcpy
00012c  2006              MOVS     r0,#6                 ;124
00012e  e793              B        |L1.88|
                  |L1.304|
000130  2200              MOVS     r2,#0                 ;140
000132  4611              MOV      r1,r2                 ;140
000134  f8d90000          LDR      r0,[r9,#0]            ;140  ; g_blobs
000138  f7fffffe          BL       _ZN5Blobs10getMaxBlobEtPt ; Blobs::getMaxBlob(unsigned short, unsigned short*)
00013c  b140              CBZ      r0,|L1.336|
00013e  1c41              ADDS     r1,r0,#1              ;143
000140  d000              BEQ      |L1.324|
000142  b165              CBZ      r5,|L1.350|
                  |L1.324|
000144  465a              MOV      r2,r11                ;144
000146  2107              MOVS     r1,#7                 ;144
000148  4620              MOV      r0,r4                 ;144
00014a  f7fffffe          BL       __aeabi_memset
00014e  e030              B        |L1.434|
                  |L1.336|
000150  f8c48000          STR      r8,[r4,#0]            ;142
000154  f8a48004          STRH     r8,[r4,#4]            ;142
000158  f8848006          STRB     r8,[r4,#6]            ;142
00015c  e029              B        |L1.434|
                  |L1.350|
00015e  8881              LDRH     r1,[r0,#4]            ;147
000160  8842              LDRH     r2,[r0,#2]            ;147
000162  1a89              SUBS     r1,r1,r2              ;147
000164  8902              LDRH     r2,[r0,#8]            ;148
000166  88c3              LDRH     r3,[r0,#6]            ;148
000168  1ad2              SUBS     r2,r2,r3              ;148
00016a  8803              LDRH     r3,[r0,#0]            ;149
00016c  8023              STRH     r3,[r4,#0]            ;149
00016e  8843              LDRH     r3,[r0,#2]            ;150
000170  f240353d          MOV      r5,#0x33d             ;150
000174  eb030351          ADD      r3,r3,r1,LSR #1       ;150
000178  436b              MULS     r3,r5,r3              ;150
00017a  0a9b              LSRS     r3,r3,#10             ;150
00017c  70a3              STRB     r3,[r4,#2]            ;151
00017e  88c3              LDRH     r3,[r0,#6]            ;152
000180  f24045ee          MOV      r5,#0x4ee             ;152
000184  eb030352          ADD      r3,r3,r2,LSR #1       ;152
000188  436b              MULS     r3,r5,r3              ;152
00018a  0a9b              LSRS     r3,r3,#10             ;152
00018c  70e3              STRB     r3,[r4,#3]            ;153
00018e  f240333d          MOV      r3,#0x33d             ;154
000192  4359              MULS     r1,r3,r1              ;154
000194  0a89              LSRS     r1,r1,#10             ;154
000196  7121              STRB     r1,[r4,#4]            ;155
000198  4629              MOV      r1,r5                 ;156
00019a  434a              MULS     r2,r1,r2              ;156
00019c  0a91              LSRS     r1,r2,#10             ;156
00019e  7161              STRB     r1,[r4,#5]            ;157
0001a0  8801              LDRH     r1,[r0,#0]            ;158
0001a2  2907              CMP      r1,#7                 ;158
0001a4  d905              BLS      |L1.434|
0001a6  8940              LDRH     r0,[r0,#0xa]          ;160
0001a8  215b              MOVS     r1,#0x5b              ;160
0001aa  fb10f001          SMULBB   r0,r0,r1              ;160
0001ae  11c0              ASRS     r0,r0,#7              ;160
0001b0  7078              STRB     r0,[r7,#1]            ;161
                  |L1.434|
0001b2  2006              MOVS     r0,#6                 ;165
0001b4  e750              B        |L1.88|
                  |L1.438|
0001b6  7878              LDRB     r0,[r7,#1]            ;169  ; g_angle
0001b8  7020              STRB     r0,[r4,#0]            ;169
0001ba  2001              MOVS     r0,#1                 ;170
0001bc  e74c              B        |L1.88|
                  |L1.446|
0001be  f8c48000          STR      r8,[r4,#0]            ;184
0001c2  f8848004          STRB     r8,[r4,#4]            ;184
0001c6  e021              B        |L1.524|
                  |L1.456|
0001c8  e022              B        |L1.528|
                  |L1.458|
0001ca  8881              LDRH     r1,[r0,#4]            ;189
0001cc  8842              LDRH     r2,[r0,#2]            ;189
0001ce  1a89              SUBS     r1,r1,r2              ;189
0001d0  8902              LDRH     r2,[r0,#8]            ;190
0001d2  88c3              LDRH     r3,[r0,#6]            ;190
0001d4  1ad2              SUBS     r2,r2,r3              ;190
0001d6  f8bd301c          LDRH     r3,[sp,#0x1c]         ;191
0001da  7023              STRB     r3,[r4,#0]            ;191
0001dc  8843              LDRH     r3,[r0,#2]            ;192
0001de  f240353d          MOV      r5,#0x33d             ;192
0001e2  eb030351          ADD      r3,r3,r1,LSR #1       ;192
0001e6  436b              MULS     r3,r5,r3              ;192
0001e8  0a9b              LSRS     r3,r3,#10             ;192
0001ea  7063              STRB     r3,[r4,#1]            ;193
0001ec  88c0              LDRH     r0,[r0,#6]            ;194
0001ee  f24043ee          MOV      r3,#0x4ee             ;194
0001f2  eb000052          ADD      r0,r0,r2,LSR #1       ;194
0001f6  4358              MULS     r0,r3,r0              ;194
0001f8  0a80              LSRS     r0,r0,#10             ;194
0001fa  70a0              STRB     r0,[r4,#2]            ;195
0001fc  4628              MOV      r0,r5                 ;196
0001fe  4341              MULS     r1,r0,r1              ;196
000200  0a88              LSRS     r0,r1,#10             ;196
000202  70e0              STRB     r0,[r4,#3]            ;197
000204  4618              MOV      r0,r3                 ;198
000206  4342              MULS     r2,r0,r2              ;198
000208  0a90              LSRS     r0,r2,#10             ;198
00020a  7120              STRB     r0,[r4,#4]            ;199
                  |L1.524|
00020c  2005              MOVS     r0,#5                 ;202
00020e  e723              B        |L1.88|
                  |L1.528|
000210  2858              CMP      r0,#0x58              ;204
000212  d00f              BEQ      |L1.564|
000214  f04f0aff          MOV      r10,#0xff             ;257
000218  285a              CMP      r0,#0x5a              ;241
00021a  d055              BEQ      |L1.712|
00021c  285e              CMP      r0,#0x5e              ;272
00021e  d073              BEQ      |L1.776|
000220  f04f0b01          MOV      r11,#1                ;84
000224  2862              CMP      r0,#0x62              ;293
000226  d070              BEQ      |L1.778|
000228  2842              CMP      r0,#0x42              ;317
00022a  d06f              BEQ      |L1.780|
00022c  f884b000          STRB     r11,[r4,#0]           ;331
                  |L1.560|
000230  2001              MOVS     r0,#1                 ;334
000232  e711              B        |L1.88|
                  |L1.564|
000234  6830              LDR      r0,[r6,#0]            ;207
000236  2202              MOVS     r2,#2                 ;207
000238  a909              ADD      r1,sp,#0x24           ;207
00023a  6883              LDR      r3,[r0,#8]            ;207
00023c  4630              MOV      r0,r6                 ;207
00023e  4798              BLX      r3                    ;207
000240  2802              CMP      r0,#2                 ;207
000242  da01              BGE      |L1.584|
000244  2000              MOVS     r0,#0                 ;208
000246  e707              B        |L1.88|
                  |L1.584|
000248  aa07              ADD      r2,sp,#0x1c           ;217
00024a  f8bd1024          LDRH     r1,[sp,#0x24]         ;217
00024e  f8d90000          LDR      r0,[r9,#0]            ;217  ; g_blobs
000252  f7fffffe          BL       _ZN5Blobs10getMaxBlobEtPt ; Blobs::getMaxBlob(unsigned short, unsigned short*)
000256  b140              CBZ      r0,|L1.618|
000258  1c41              ADDS     r1,r0,#1              ;220
00025a  d000              BEQ      |L1.606|
00025c  b155              CBZ      r5,|L1.628|
                  |L1.606|
00025e  465a              MOV      r2,r11                ;221
000260  2106              MOVS     r1,#6                 ;221
000262  4620              MOV      r0,r4                 ;221
000264  f7fffffe          BL       __aeabi_memset
000268  e02c              B        |L1.708|
                  |L1.618|
00026a  f8c48000          STR      r8,[r4,#0]            ;219
00026e  f8a48004          STRH     r8,[r4,#4]            ;219
000272  e027              B        |L1.708|
                  |L1.628|
000274  8881              LDRH     r1,[r0,#4]            ;224
000276  8842              LDRH     r2,[r0,#2]            ;224
000278  1a89              SUBS     r1,r1,r2              ;224
00027a  8902              LDRH     r2,[r0,#8]            ;225
00027c  88c3              LDRH     r3,[r0,#6]            ;225
00027e  1ad2              SUBS     r2,r2,r3              ;225
000280  f8bd301c          LDRH     r3,[sp,#0x1c]         ;226
000284  7023              STRB     r3,[r4,#0]            ;226
000286  8843              LDRH     r3,[r0,#2]            ;227
000288  f240353d          MOV      r5,#0x33d             ;227
00028c  eb030351          ADD      r3,r3,r1,LSR #1       ;227
000290  436b              MULS     r3,r5,r3              ;227
000292  0a9b              LSRS     r3,r3,#10             ;227
000294  7063              STRB     r3,[r4,#1]            ;228
000296  88c3              LDRH     r3,[r0,#6]            ;229
000298  f24045ee          MOV      r5,#0x4ee             ;229
00029c  eb030352          ADD      r3,r3,r2,LSR #1       ;229
0002a0  436b              MULS     r3,r5,r3              ;229
0002a2  0a9b              LSRS     r3,r3,#10             ;229
0002a4  70a3              STRB     r3,[r4,#2]            ;230
0002a6  f240333d          MOV      r3,#0x33d             ;231
0002aa  4359              MULS     r1,r3,r1              ;231
0002ac  0a89              LSRS     r1,r1,#10             ;231
0002ae  70e1              STRB     r1,[r4,#3]            ;232
0002b0  4629              MOV      r1,r5                 ;233
0002b2  434a              MULS     r2,r1,r2              ;233
0002b4  0a91              LSRS     r1,r2,#10             ;233
0002b6  7121              STRB     r1,[r4,#4]            ;234
0002b8  8940              LDRH     r0,[r0,#0xa]          ;235
0002ba  215b              MOVS     r1,#0x5b              ;235
0002bc  fb10f001          SMULBB   r0,r0,r1              ;235
0002c0  11c0              ASRS     r0,r0,#7              ;235
0002c2  7160              STRB     r0,[r4,#5]            ;236
                  |L1.708|
0002c4  2006              MOVS     r0,#6                 ;239
0002c6  e6c7              B        |L1.88|
                  |L1.712|
0002c8  6830              LDR      r0,[r6,#0]            ;243
0002ca  2201              MOVS     r2,#1                 ;243
0002cc  a908              ADD      r1,sp,#0x20           ;243
0002ce  6883              LDR      r3,[r0,#8]            ;243
0002d0  4630              MOV      r0,r6                 ;243
0002d2  4798              BLX      r3                    ;243
0002d4  2801              CMP      r0,#1                 ;243
0002d6  d110              BNE      |L1.762|
0002d8  6830              LDR      r0,[r6,#0]            ;244
0002da  2201              MOVS     r2,#1                 ;244
0002dc  a90b              ADD      r1,sp,#0x2c           ;244
0002de  6883              LDR      r3,[r0,#8]            ;244
0002e0  4630              MOV      r0,r6                 ;244
0002e2  4798              BLX      r3                    ;244
0002e4  2801              CMP      r0,#1                 ;244
0002e6  d108              BNE      |L1.762|
0002e8  6830              LDR      r0,[r6,#0]            ;245
0002ea  2201              MOVS     r2,#1                 ;245
0002ec  a90a              ADD      r1,sp,#0x28           ;245
0002ee  6883              LDR      r3,[r0,#8]            ;245
0002f0  4630              MOV      r0,r6                 ;245
0002f2  4798              BLX      r3                    ;245
0002f4  2801              CMP      r0,#1                 ;245
0002f6  d100              BNE      |L1.762|
0002f8  b14d              CBZ      r5,|L1.782|
                  |L1.762|
0002fa  465a              MOV      r2,r11                ;268
0002fc  2104              MOVS     r1,#4                 ;268
0002fe  4620              MOV      r0,r4                 ;268
000300  f7fffffe          BL       __aeabi_memset
000304  2004              MOVS     r0,#4                 ;269
000306  e6a7              B        |L1.88|
                  |L1.776|
000308  e03b              B        |L1.898|
                  |L1.778|
00030a  e091              B        |L1.1072|
                  |L1.780|
00030c  e0c6              B        |L1.1180|
                  |L1.782|
00030e  f99d0020          LDRSB    r0,[sp,#0x20]         ;248
000312  21b4              MOVS     r1,#0xb4              ;249
000314  fb10f001          SMULBB   r0,r0,r1              ;249
000318  b200              SXTH     r0,r0                 ;249
00031a  217f              MOVS     r1,#0x7f              ;250
00031c  fb90f0f1          SDIV     r0,r0,r1              ;250
000320  b200              SXTH     r0,r0                 ;250
000322  f7fffffe          BL       _Z21line_setNextTurnAngles ; line_setNextTurnAngle(short)
000326  89f8              LDRH     r0,[r7,#0xe]          ;252  ; lastReverse
000328  f5a0417f          SUB      r1,r0,#0xff00         ;252
00032c  39ff              SUBS     r1,r1,#0xff           ;252
00032e  d005              BEQ      |L1.828|
000330  f89d102c          LDRB     r1,[sp,#0x2c]         ;252
000334  4288              CMP      r0,r1                 ;252
000336  d001              BEQ      |L1.828|
000338  f7fffffe          BL       _Z19line_reversePrimaryv ; line_reversePrimary()
                  |L1.828|
00033c  79b9              LDRB     r1,[r7,#6]            ;254  ; lastLamp
00033e  f89d0028          LDRB     r0,[sp,#0x28]         ;254
000342  4281              CMP      r1,r0                 ;254
000344  d011              BEQ      |L1.874|
000346  b140              CBZ      r0,|L1.858|
000348  f8cda00c          STR      r10,[sp,#0xc]         ;257
00034c  a902              ADD      r1,sp,#8              ;257
00034e  a803              ADD      r0,sp,#0xc            ;257
000350  f8cda008          STR      r10,[sp,#8]           ;257
000354  f7fffffe          BL       _Z11led_setLampRKhS0_ ; led_setLamp(const unsigned char&, const unsigned char&)
000358  e007              B        |L1.874|
                  |L1.858|
00035a  f8cd800c          STR      r8,[sp,#0xc]          ;259
00035e  a902              ADD      r1,sp,#8              ;259
000360  a803              ADD      r0,sp,#0xc            ;259
000362  f8cd8008          STR      r8,[sp,#8]            ;259
000366  f7fffffe          BL       _Z11led_setLampRKhS0_ ; led_setLamp(const unsigned char&, const unsigned char&)
                  |L1.874|
00036a  f89d002c          LDRB     r0,[sp,#0x2c]         ;262
00036e  81f8              STRH     r0,[r7,#0xe]          ;262
000370  f89d0028          LDRB     r0,[sp,#0x28]         ;263
000374  71b8              STRB     r0,[r7,#6]            ;263
000376  4620              MOV      r0,r4                 ;264
000378  990e              LDR      r1,[sp,#0x38]         ;264
00037a  f7fffffe          BL       _Z17line_legoLineDataPhj ; line_legoLineData(unsigned char*, unsigned)
00037e  b280              UXTH     r0,r0                 ;264
000380  e66a              B        |L1.88|
                  |L1.898|
000382  6830              LDR      r0,[r6,#0]            ;274
000384  2203              MOVS     r2,#3                 ;274
000386  4621              MOV      r1,r4                 ;274
000388  6883              LDR      r3,[r0,#8]            ;274
00038a  4630              MOV      r0,r6                 ;274
00038c  4798              BLX      r3                    ;274
00038e  2803              CMP      r0,#3                 ;274
000390  d100              BNE      |L1.916|
000392  b135              CBZ      r5,|L1.930|
                  |L1.916|
000394  465a              MOV      r2,r11                ;289
000396  2103              MOVS     r1,#3                 ;289
000398  4620              MOV      r0,r4                 ;289
00039a  f7fffffe          BL       __aeabi_memset
00039e  2003              MOVS     r0,#3                 ;290
0003a0  e65a              B        |L1.88|
                  |L1.930|
0003a2  7820              LDRB     r0,[r4,#0]            ;277
0003a4  ebc01080          RSB      r0,r0,r0,LSL #6       ;277
0003a8  eb000080          ADD      r0,r0,r0,LSL #2       ;277
0003ac  fbb0f0fa          UDIV     r0,r0,r10             ;277
0003b0  b280              UXTH     r0,r0                 ;277
0003b2  7861              LDRB     r1,[r4,#1]            ;278
0003b4  22cf              MOVS     r2,#0xcf              ;278
0003b6  fb11f102          SMULBB   r1,r1,r2              ;278
0003ba  fbb1f1fa          UDIV     r1,r1,r10             ;278
0003be  78a2              LDRB     r2,[r4,#2]            ;279
0003c0  b102              CBZ      r2,|L1.964|
0003c2  2201              MOVS     r2,#1                 ;279
                  |L1.964|
0003c4  f7fffffe          BL       _Z6getRGBtth ; getRGB(unsigned short, unsigned short, unsigned char)
0003c8  ab04              ADD      r3,sp,#0x10           ;281
0003ca  aa05              ADD      r2,sp,#0x14           ;281
0003cc  a906              ADD      r1,sp,#0x18           ;281
0003ce  f7fffffe          BL       _Z9rgbUnpackjPjS_S_ ; rgbUnpack(unsigned, unsigned*, unsigned*, unsigned*)
0003d2  9806              LDR      r0,[sp,#0x18]         ;282
0003d4  7020              STRB     r0,[r4,#0]            ;282
0003d6  9805              LDR      r0,[sp,#0x14]         ;283
0003d8  7060              STRB     r0,[r4,#1]            ;283
0003da  9804              LDR      r0,[sp,#0x10]         ;284
0003dc  70a0              STRB     r0,[r4,#2]            ;284
0003de  2003              MOVS     r0,#3                 ;285
0003e0  e63a              B        |L1.88|
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      ||.data||
                  |L1.1000|
0003e8  636f6c6f          DCB      "color_connected_components",0
0003ec  725f636f
0003f0  6e6e6563
0003f4  7465645f
0003f8  636f6d70
0003fc  6f6e656e
000400  747300  
000403  00                DCB      0
                  |L1.1028|
000404  6c696e65          DCB      "line_tracking",0
000408  5f747261
00040c  636b696e
000410  6700    
000412  00                DCB      0
000413  00                DCB      0
                  |L1.1044|
000414  76696465          DCB      "video",0
000418  6f00    
00041a  00                DCB      0
00041b  00                DCB      0
                  |L1.1052|
                          DCD      g_blobs
                  |L1.1056|
000420  56302e34          DCB      "V0.4",0
000424  00      
000425  00                DCB      0
000426  00                DCB      0
000427  00                DCB      0
                  |L1.1064|
000428  50697879          DCB      "Pixy2",0
00042c  3200    
00042e  00                DCB      0
00042f  00                DCB      0
                  |L1.1072|
000430  6830              LDR      r0,[r6,#0]            ;295
000432  2201              MOVS     r2,#1                 ;295
000434  a90a              ADD      r1,sp,#0x28           ;295
000436  6883              LDR      r3,[r0,#8]            ;295
000438  4630              MOV      r0,r6                 ;295
00043a  4798              BLX      r3                    ;295
00043c  2801              CMP      r0,#1                 ;295
00043e  d129              BNE      |L1.1172|
000440  b9fd              CBNZ     r5,|L1.1154|
000442  79f8              LDRB     r0,[r7,#7]            ;298  ; ccc
000444  9003              STR      r0,[sp,#0xc]          ;298
000446  2100              MOVS     r1,#0                 ;298
000448  a803              ADD      r0,sp,#0xc            ;298
00044a  f7fffffe          BL       _Z12exec_getProgRKhP5Chirp ; exec_getProg(const unsigned char&, Chirp*)
00044e  2801              CMP      r0,#1                 ;298
000450  d00b              BEQ      |L1.1130|
000452  f89d0028          LDRB     r0,[sp,#0x28]         ;300
000456  b1a8              CBZ      r0,|L1.1156|
000458  f8cda008          STR      r10,[sp,#8]           ;301
00045c  a901              ADD      r1,sp,#4              ;301
00045e  a802              ADD      r0,sp,#8              ;301
000460  f8cda004          STR      r10,[sp,#4]           ;301
000464  f7fffffe          BL       _Z11led_setLampRKhS0_ ; led_setLamp(const unsigned char&, const unsigned char&)
000468  e014              B        |L1.1172|
                  |L1.1130|
00046a  f89d0028          LDRB     r0,[sp,#0x28]         ;299
00046e  b108              CBZ      r0,|L1.1140|
000470  20ff              MOVS     r0,#0xff              ;299
000472  e000              B        |L1.1142|
                  |L1.1140|
000474  2000              MOVS     r0,#0                 ;299
                  |L1.1142|
000476  e9cd8001          STRD     r8,r0,[sp,#4]         ;299
00047a  a901              ADD      r1,sp,#4              ;299
00047c  a802              ADD      r0,sp,#8              ;299
00047e  f7fffffe          BL       _Z11led_setLampRKhS0_ ; led_setLamp(const unsigned char&, const unsigned char&)
                  |L1.1154|
000482  e007              B        |L1.1172|
                  |L1.1156|
000484  f8cd8008          STR      r8,[sp,#8]            ;303
000488  a901              ADD      r1,sp,#4              ;303
00048a  a802              ADD      r0,sp,#8              ;303
00048c  f8cd8004          STR      r8,[sp,#4]            ;303
000490  f7fffffe          BL       _Z11led_setLampRKhS0_ ; led_setLamp(const unsigned char&, const unsigned char&)
                  |L1.1172|
000494  f884b000          STRB     r11,[r4,#0]           ;305
000498  2001              MOVS     r0,#1                 ;306
00049a  e5dd              B        |L1.88|
                  |L1.1180|
00049c  2200              MOVS     r2,#0                 ;320
00049e  4611              MOV      r1,r2                 ;320
0004a0  f8d90000          LDR      r0,[r9,#0]            ;320  ; g_blobs
0004a4  f7fffffe          BL       _ZN5Blobs10getMaxBlobEtPt ; Blobs::getMaxBlob(unsigned short, unsigned short*)
0004a8  b160              CBZ      r0,|L1.1220|
0004aa  1c41              ADDS     r1,r0,#1              ;321
0004ac  d00a              BEQ      |L1.1220|
0004ae  8881              LDRH     r1,[r0,#4]            ;325
0004b0  8840              LDRH     r0,[r0,#2]            ;325
0004b2  1a09              SUBS     r1,r1,r0              ;325
0004b4  eb000051          ADD      r0,r0,r1,LSR #1       ;326
0004b8  f240313d          MOV      r1,#0x33d             ;326
0004bc  4348              MULS     r0,r1,r0              ;326
0004be  0a80              LSRS     r0,r0,#10             ;326
0004c0  7020              STRB     r0,[r4,#0]            ;327
0004c2  e6b5              B        |L1.560|
                  |L1.1220|
0004c4  f8848000          STRB     r8,[r4,#0]            ;322
0004c8  e6b2              B        |L1.560|
;;;337    
                          ENDP

                  _Z9ser_setTxhhb PROC ; ser_setTx(unsigned char, unsigned char, bool)
;;;607    
;;;608    void ser_setTx(uint8_t type, uint8_t len, bool checksum)
0004ca  b4f0              PUSH     {r4-r7}
;;;609    {
;;;610    	uint8_t i;
;;;611    	uint16_t cs;
;;;612    	
;;;613    	g_txReadIndex = 0;
0004cc  4dfc              LDR      r5,|L1.2240|
0004ce  2300              MOVS     r3,#0
0004d0  82ab              STRH     r3,[r5,#0x14]
;;;614    	g_txLen = SER_MIN_PACKET_HEADER + len;
0004d2  1d0e              ADDS     r6,r1,#4
0004d4  82ee              STRH     r6,[r5,#0x16]
;;;615    	if (checksum)
0004d6  2a00              CMP      r2,#0
0004d8  d015              BEQ      |L1.1286|
;;;616    	{	
;;;617    		g_tx = g_txBuf;
0004da  4cfa              LDR      r4,|L1.2244|
0004dc  622c              STR      r4,[r5,#0x20]  ; g_tx
0004de  4627              MOV      r7,r4
;;;618    		*(uint16_t *)g_tx = SER_SYNC_CHECKSUM;
0004e0  f24c12af          MOV      r2,#0xc1af
0004e4  8022              STRH     r2,[r4,#0]
;;;619    		for (i=0, cs=0; i<len; i++)
0004e6  2200              MOVS     r2,#0
0004e8  e007              B        |L1.1274|
                  |L1.1258|
;;;620    			cs += g_txBuf[SER_MAX_PACKET_HEADER + i];
0004ea  eb040c02          ADD      r12,r4,r2
0004ee  f89cc006          LDRB     r12,[r12,#6]
0004f2  4463              ADD      r3,r3,r12
0004f4  b29b              UXTH     r3,r3
0004f6  1c52              ADDS     r2,r2,#1              ;619
0004f8  b2d2              UXTB     r2,r2                 ;619
                  |L1.1274|
0004fa  428a              CMP      r2,r1                 ;619
0004fc  d3f5              BCC      |L1.1258|
;;;621    		*(uint16_t *)(g_tx+4) = cs;
0004fe  80bb              STRH     r3,[r7,#4]
;;;622    		g_txLen += SER_PACKET_HEADER_CS_SIZE;
000500  1cb6              ADDS     r6,r6,#2
000502  82ee              STRH     r6,[r5,#0x16]
000504  e005              B        |L1.1298|
                  |L1.1286|
;;;623    	}
;;;624    	else
;;;625    	{
;;;626    		g_tx = g_txBuf + SER_PACKET_HEADER_CS_SIZE;
000506  4aef              LDR      r2,|L1.2244|
000508  1c92              ADDS     r2,r2,#2
00050a  622a              STR      r2,[r5,#0x20]  ; g_tx
;;;627    		*(uint16_t *)g_tx = SER_SYNC_NO_CHECKSUM;
00050c  f24c13ae          MOV      r3,#0xc1ae
000510  8013              STRH     r3,[r2,#0]
                  |L1.1298|
;;;628    	}
;;;629    	g_tx[2] = type;
000512  6a2a              LDR      r2,[r5,#0x20]  ; g_tx
000514  7090              STRB     r0,[r2,#2]
;;;630    	g_tx[3] = len;
000516  70d1              STRB     r1,[r2,#3]
;;;631    	g_newPacket = true;
000518  2001              MOVS     r0,#1
00051a  7128              STRB     r0,[r5,#4]
;;;632    	g_serial->startTransmit();
00051c  69e8              LDR      r0,[r5,#0x1c]  ; g_serial
00051e  6801              LDR      r1,[r0,#0]
000520  6949              LDR      r1,[r1,#0x14]
000522  bcf0              POP      {r4-r7}
000524  4708              BX       r1
;;;633    }
;;;634    
                          ENDP

                  _Z9ser_getTxPPh PROC ; ser_getTx(unsigned char**)
;;;601    // the tx buffer and the txCallback reading the tx buffer. 
;;;602    uint8_t ser_getTx(uint8_t **data)
000526  49e7              LDR      r1,|L1.2244|
;;;603    {
;;;604    	*data = g_txBuf+SER_MAX_PACKET_HEADER; // make room for header
000528  1d89              ADDS     r1,r1,#6
00052a  6001              STR      r1,[r0,#0]
;;;605    	return SER_TXBUF_SIZE-SER_MAX_PACKET_HEADER;
00052c  20ff              MOVS     r0,#0xff
;;;606    }
00052e  4770              BX       lr
;;;607    
                          ENDP

                  _Z14ser_sendResultib PROC ; ser_sendResult(int, bool)
;;;337    
;;;338    void ser_sendResult(int32_t val, bool checksum)
000530  b508              PUSH     {r3,lr}
;;;339    {
000532  4603              MOV      r3,r0
000534  460a              MOV      r2,r1
;;;340    	uint8_t *txData;
;;;341    	ser_getTx(&txData);
000536  4668              MOV      r0,sp
000538  f7fffffe          BL       _Z9ser_getTxPPh ; ser_getTx(unsigned char**)
;;;342    	*(int32_t *)txData = val; // write val
00053c  9800              LDR      r0,[sp,#0]
00053e  6003              STR      r3,[r0,#0]
;;;343    			
;;;344    	ser_setTx(SER_TYPE_RESPONSE_RESULT, sizeof(int32_t), checksum);				
000540  2104              MOVS     r1,#4
000542  2001              MOVS     r0,#1
000544  f7fffffe          BL       _Z9ser_setTxhhb ; ser_setTx(unsigned char, unsigned char, bool)
;;;345    }
000548  bd08              POP      {r3,pc}
;;;346    void ser_sendResults(uint8_t* vals, uint8_t len, bool checksum)
                          ENDP

                  _Z15ser_sendResultsPhhb PROC ; ser_sendResults(unsigned char*, unsigned char, bool)
00054a  b5f8              PUSH     {r3-r7,lr}
;;;347    {
00054c  4604              MOV      r4,r0
00054e  460e              MOV      r6,r1
;;;348    	uint8_t *txData;
;;;349    	ser_getTx(&txData);
000550  4668              MOV      r0,sp
000552  f7fffffe          BL       _Z9ser_getTxPPh ; ser_getTx(unsigned char**)
;;;350    	for(uint8_t i = 0; i < len; i++) *(txData + i) = *(vals+i);
000556  2300              MOVS     r3,#0
000558  9d00              LDR      r5,[sp,#0]            ;348
00055a  e003              B        |L1.1380|
                  |L1.1372|
00055c  5ce0              LDRB     r0,[r4,r3]
00055e  54e8              STRB     r0,[r5,r3]
000560  1c5b              ADDS     r3,r3,#1
000562  b2db              UXTB     r3,r3
                  |L1.1380|
000564  42b3              CMP      r3,r6
000566  d3f9              BCC      |L1.1372|
;;;351    			
;;;352    	ser_setTx(SER_TYPE_RESPONSE_RESULT, len * sizeof(uint8_t), checksum);				
000568  4631              MOV      r1,r6
00056a  2001              MOVS     r0,#1
00056c  f7fffffe          BL       _Z9ser_setTxhhb ; ser_setTx(unsigned char, unsigned char, bool)
;;;353    }
000570  bdf8              POP      {r3-r7,pc}
;;;354    
                          ENDP

                  _Z13ser_sendErrorab PROC ; ser_sendError(signed char, bool)
;;;355    void ser_sendError(int8_t error, bool checksum)
000572  b508              PUSH     {r3,lr}
;;;356    {
000574  4603              MOV      r3,r0
000576  460a              MOV      r2,r1
;;;357    	uint8_t *txData;
;;;358    	ser_getTx(&txData);
000578  4668              MOV      r0,sp
00057a  f7fffffe          BL       _Z9ser_getTxPPh ; ser_getTx(unsigned char**)
;;;359    	txData[0] = error;
00057e  9800              LDR      r0,[sp,#0]
000580  7003              STRB     r3,[r0,#0]
;;;360    	ser_setTx(SER_TYPE_RESPONSE_ERROR, 1, checksum);	
000582  2101              MOVS     r1,#1
000584  2003              MOVS     r0,#3
000586  f7fffffe          BL       _Z9ser_setTxhhb ; ser_setTx(unsigned char, unsigned char, bool)
;;;361    }
00058a  bd08              POP      {r3,pc}
;;;362    
                          ENDP

                  _Z10ser_packethPKhhb PROC ; ser_packet(unsigned char, const unsigned char*, unsigned char, bool)
;;;363    
;;;364    void ser_packet(uint8_t type, const uint8_t *rxData, uint8_t len, bool checksum)
00058c  e92d41fc          PUSH     {r2-r8,lr}
;;;365    {
000590  460c              MOV      r4,r1
000592  461d              MOV      r5,r3
;;;366    	uint8_t *txData;
;;;367    	int res;
;;;368    	
;;;369    	// first check if current program can handle request 
;;;370    	if (type>SER_TYPE_REQUEST_NO_PROG_MAX)
000594  281f              CMP      r0,#0x1f
000596  d905              BLS      |L1.1444|
;;;371    		exec_progPacket(type, rxData, len, checksum);
000598  462b              MOV      r3,r5
00059a  4621              MOV      r1,r4
00059c  f7fffffe          BL       _Z15exec_progPackethPKhhb ; exec_progPacket(unsigned char, const unsigned char*, unsigned char, bool)
                  |L1.1440|
;;;372    	else if (type==SER_TYPE_REQUEST_CHANGE_PROG)
;;;373    	{
;;;374    		res = exec_runProgName((const char *)rxData);
;;;375    		if (res<0)
;;;376    			ser_sendError(SER_ERROR_INVALID_REQUEST, checksum);
;;;377    		else
;;;378    			ser_sendResult(res, checksum);
;;;379    	}
;;;380    	else if (type==SER_TYPE_REQUEST_RESOLUTION)
;;;381    	{
;;;382    		if (len!=1)
;;;383    			ser_sendError(SER_ERROR_INVALID_REQUEST, checksum);	
;;;384    		else
;;;385    			if (exec_progResolution(rxData[0], checksum)<0)
;;;386    				ser_sendError(SER_ERROR_PROG_CHANGING, checksum);
;;;387    	}
;;;388    	else if (type==SER_TYPE_REQUEST_VERSION) // get version information
;;;389    	{
;;;390    		uint32_t hwVal;
;;;391    		
;;;392    		// this mechanism provides feedback to serial client that we're ready to accept input after "boot-up"
;;;393    		// If g_ready is false, we're not ready...
;;;394    		if (!g_ready)
;;;395    		{
;;;396    			ser_sendError(SER_ERROR_BUSY, checksum);
;;;397    			return;
;;;398    		}
;;;399    				
;;;400    		ser_getTx(&txData);
;;;401    		// hw version, first 2 bytes
;;;402    		hwVal = *(uint32_t *)(0x40045000+0x38);
;;;403    		if (hwVal>>16==0xc1ab)
;;;404    			*(uint16_t *)(txData + 0) = hwVal&0xffff;
;;;405    		else // if value isn't set, assume Pixy version 1.3b 
;;;406    			*(uint16_t *)(txData + 0) = 0x1301;				
;;;407    		// fw version, next 4 bytes
;;;408    		*(uint8_t *)(txData + 2) = FW_MAJOR_VER;
;;;409    		*(uint8_t *)(txData + 3) = FW_MINOR_VER;
;;;410    		*(uint16_t *)(txData + 4) = FW_BUILD_VER;
;;;411    		
;;;412    		// fw type, next 10 bytes
;;;413    		strncpy((char *)txData+6, FW_TYPE, 10);
;;;414    			
;;;415    		ser_setTx(SER_TYPE_RESPONSE_VERSION, 16, checksum);
;;;416    	}
;;;417    	else if (type==SER_TYPE_REQUEST_BRIGHTNESS) // set brightness
;;;418    	{
;;;419    		if (len!=1)
;;;420    			ser_sendError(SER_ERROR_INVALID_REQUEST, checksum);
;;;421    		else
;;;422    		{
;;;423    			// "queue" up the brightness request because it goes out over i2c and takes time
;;;424    			g_brightnessQ.m_valid = true;
;;;425    			g_brightnessQ.m_brightness = rxData[0];
;;;426    			ser_sendResult(0, checksum);
;;;427    		}
;;;428    	}
;;;429    	else if (type==SER_TYPE_REQUEST_SERVO) // set servo positions
;;;430    	{
;;;431    		if (len!=4)
;;;432    			ser_sendError(SER_ERROR_INVALID_REQUEST, checksum);
;;;433    		else
;;;434    		{
;;;435    			rcs_setPos(0, *(uint16_t *)rxData);
;;;436    			rcs_setPos(1, *(uint16_t *)&rxData[2]);
;;;437    			ser_sendResult(0, checksum);
;;;438    		}
;;;439    	}
;;;440    	else if (type==SER_TYPE_REQUEST_LED) // set LED 
;;;441    	{
;;;442    		if (len!=3)
;;;443    			ser_sendError(SER_ERROR_INVALID_REQUEST, checksum);
;;;444    		else
;;;445    		{
;;;446    			// set override, user is now in control
;;;447    			cc_setLEDOverride(true);
;;;448    			led_setRGB(rxData[0], rxData[1], rxData[2]);
;;;449    			ser_sendResult(0, checksum);
;;;450    		}
;;;451    	}
;;;452    	else if (type==SER_TYPE_REQUEST_LAMP) // set lamp
;;;453    	{
;;;454    		if (len!=2)
;;;455    			ser_sendError(SER_ERROR_INVALID_REQUEST, checksum);
;;;456    		else
;;;457    		{
;;;458    			led_setLamp(rxData[0], rxData[1]);
;;;459    			ser_sendResult(0, checksum);				
;;;460    		}				
;;;461    	}
;;;462    	else if (type==SER_TYPE_REQUEST_FPS) // get frames per second
;;;463    	{
;;;464    		float fps = cam_getFPS() + 0.5f;
;;;465    		uint32_t val = (uint32_t)fps; // convert to int, round up or down
;;;466    		ser_sendResult(val, checksum);				
;;;467    	}
;;;468    	else // not able to find handler, return error
;;;469    		ser_sendError(SER_ERROR_TYPE_UNSUPPORTED, checksum);		
;;;470    }
0005a0  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1444|
0005a4  f06f0602          MVN      r6,#2                 ;376
0005a8  2802              CMP      r0,#2                 ;372
0005aa  d014              BEQ      |L1.1494|
0005ac  280c              CMP      r0,#0xc               ;380
0005ae  d021              BEQ      |L1.1524|
0005b0  2300              MOVS     r3,#0                 ;388
0005b2  280e              CMP      r0,#0xe               ;388
0005b4  d031              BEQ      |L1.1562|
0005b6  2701              MOVS     r7,#1                 ;365
0005b8  2810              CMP      r0,#0x10              ;417
0005ba  d059              BEQ      |L1.1648|
0005bc  2812              CMP      r0,#0x12              ;429
0005be  d068              BEQ      |L1.1682|
0005c0  2814              CMP      r0,#0x14              ;440
0005c2  d07f              BEQ      |L1.1732|
0005c4  2816              CMP      r0,#0x16              ;452
0005c6  d07b              BEQ      |L1.1728|
0005c8  2818              CMP      r0,#0x18              ;462
0005ca  d07a              BEQ      |L1.1730|
0005cc  4629              MOV      r1,r5                 ;469
0005ce  1f18              SUBS     r0,r3,#4              ;469
0005d0  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
0005d4  e7e4              B        |L1.1440|
                  |L1.1494|
0005d6  2100              MOVS     r1,#0                 ;374
0005d8  4620              MOV      r0,r4                 ;374
0005da  f7fffffe          BL       _Z16exec_runProgNamePKcP5Chirp ; exec_runProgName(const char*, Chirp*)
0005de  2800              CMP      r0,#0                 ;375
0005e0  da04              BGE      |L1.1516|
0005e2  4629              MOV      r1,r5                 ;376
0005e4  4630              MOV      r0,r6                 ;376
0005e6  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
0005ea  e7d9              B        |L1.1440|
                  |L1.1516|
0005ec  4629              MOV      r1,r5                 ;378
0005ee  f7fffffe          BL       _Z14ser_sendResultib ; ser_sendResult(int, bool)
0005f2  e7d5              B        |L1.1440|
                  |L1.1524|
0005f4  2a01              CMP      r2,#1                 ;382
0005f6  d004              BEQ      |L1.1538|
0005f8  4629              MOV      r1,r5                 ;383
0005fa  4630              MOV      r0,r6                 ;383
0005fc  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
000600  e7ce              B        |L1.1440|
                  |L1.1538|
000602  7820              LDRB     r0,[r4,#0]            ;385
000604  4629              MOV      r1,r5                 ;385
000606  f7fffffe          BL       _Z19exec_progResolutionhb ; exec_progResolution(unsigned char, bool)
00060a  2800              CMP      r0,#0                 ;385
00060c  dac8              BGE      |L1.1440|
00060e  4629              MOV      r1,r5                 ;386
000610  f06f0005          MVN      r0,#5                 ;386
000614  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
000618  e7c2              B        |L1.1440|
                  |L1.1562|
00061a  48a9              LDR      r0,|L1.2240|
00061c  7940              LDRB     r0,[r0,#5]            ;394  ; g_ready
00061e  b160              CBZ      r0,|L1.1594|
000620  a801              ADD      r0,sp,#4              ;400
000622  f7fffffe          BL       _Z9ser_getTxPPh ; ser_getTx(unsigned char**)
000626  48a8              LDR      r0,|L1.2248|
000628  6b80              LDR      r0,[r0,#0x38]         ;402
00062a  f24c11ab          MOV      r1,#0xc1ab            ;403
00062e  ebb14f10          CMP      r1,r0,LSR #16         ;403
000632  d108              BNE      |L1.1606|
000634  9901              LDR      r1,[sp,#4]            ;404
000636  8008              STRH     r0,[r1,#0]            ;404
000638  e009              B        |L1.1614|
                  |L1.1594|
00063a  4629              MOV      r1,r5                 ;396
00063c  f06f0001          MVN      r0,#1                 ;396
000640  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
000644  e7ac              B        |L1.1440|
                  |L1.1606|
000646  9901              LDR      r1,[sp,#4]            ;406
000648  f2413001          MOV      r0,#0x1301            ;406
00064c  8008              STRH     r0,[r1,#0]            ;406
                  |L1.1614|
00064e  9801              LDR      r0,[sp,#4]            ;408
000650  2103              MOVS     r1,#3                 ;408
000652  7081              STRB     r1,[r0,#2]            ;408
000654  70c3              STRB     r3,[r0,#3]            ;409
000656  2112              MOVS     r1,#0x12              ;410
000658  8081              STRH     r1,[r0,#4]            ;410
00065a  220a              MOVS     r2,#0xa               ;413
00065c  a19b              ADR      r1,|L1.2252|
00065e  1d80              ADDS     r0,r0,#6              ;413
000660  f7fffffe          BL       strncpy
000664  462a              MOV      r2,r5                 ;415
000666  2110              MOVS     r1,#0x10              ;415
000668  200f              MOVS     r0,#0xf               ;415
00066a  f7fffffe          BL       _Z9ser_setTxhhb ; ser_setTx(unsigned char, unsigned char, bool)
00066e  e797              B        |L1.1440|
                  |L1.1648|
000670  2a01              CMP      r2,#1                 ;419
000672  d004              BEQ      |L1.1662|
000674  4629              MOV      r1,r5                 ;420
000676  4630              MOV      r0,r6                 ;420
000678  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
00067c  e790              B        |L1.1440|
                  |L1.1662|
00067e  4890              LDR      r0,|L1.2240|
000680  3018              ADDS     r0,r0,#0x18           ;424
000682  7007              STRB     r7,[r0,#0]            ;424
000684  7821              LDRB     r1,[r4,#0]            ;425
000686  7041              STRB     r1,[r0,#1]            ;425
000688  4629              MOV      r1,r5                 ;426
00068a  2000              MOVS     r0,#0                 ;426
00068c  f7fffffe          BL       _Z14ser_sendResultib ; ser_sendResult(int, bool)
000690  e786              B        |L1.1440|
                  |L1.1682|
000692  2a04              CMP      r2,#4                 ;431
000694  d004              BEQ      |L1.1696|
000696  4629              MOV      r1,r5                 ;432
000698  4630              MOV      r0,r6                 ;432
00069a  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
00069e  e77f              B        |L1.1440|
                  |L1.1696|
0006a0  4621              MOV      r1,r4                 ;435
0006a2  4668              MOV      r0,sp                 ;435
0006a4  9300              STR      r3,[sp,#0]            ;435
0006a6  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
0006aa  1ca1              ADDS     r1,r4,#2              ;436
0006ac  4668              MOV      r0,sp                 ;436
0006ae  9700              STR      r7,[sp,#0]            ;436
0006b0  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
0006b4  4629              MOV      r1,r5                 ;437
0006b6  2000              MOVS     r0,#0                 ;437
0006b8  f7fffffe          BL       _Z14ser_sendResultib ; ser_sendResult(int, bool)
0006bc  e770              B        |L1.1440|
0006be  e001              B        |L1.1732|
                  |L1.1728|
0006c0  e014              B        |L1.1772|
                  |L1.1730|
0006c2  e023              B        |L1.1804|
                  |L1.1732|
0006c4  2a03              CMP      r2,#3                 ;442
0006c6  d004              BEQ      |L1.1746|
0006c8  4629              MOV      r1,r5                 ;443
0006ca  4630              MOV      r0,r6                 ;443
0006cc  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
0006d0  e766              B        |L1.1440|
                  |L1.1746|
0006d2  2001              MOVS     r0,#1                 ;447
0006d4  f7fffffe          BL       _Z17cc_setLEDOverrideb ; cc_setLEDOverride(bool)
0006d8  1ca2              ADDS     r2,r4,#2              ;448
0006da  1c61              ADDS     r1,r4,#1              ;448
0006dc  4620              MOV      r0,r4                 ;448
0006de  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
0006e2  4629              MOV      r1,r5                 ;449
0006e4  2000              MOVS     r0,#0                 ;449
0006e6  f7fffffe          BL       _Z14ser_sendResultib ; ser_sendResult(int, bool)
0006ea  e759              B        |L1.1440|
                  |L1.1772|
0006ec  2a02              CMP      r2,#2                 ;454
0006ee  d004              BEQ      |L1.1786|
0006f0  4629              MOV      r1,r5                 ;455
0006f2  4630              MOV      r0,r6                 ;455
0006f4  f7fffffe          BL       _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
0006f8  e752              B        |L1.1440|
                  |L1.1786|
0006fa  1c61              ADDS     r1,r4,#1              ;458
0006fc  4620              MOV      r0,r4                 ;458
0006fe  f7fffffe          BL       _Z11led_setLampRKhS0_ ; led_setLamp(const unsigned char&, const unsigned char&)
000702  4629              MOV      r1,r5                 ;459
000704  2000              MOVS     r0,#0                 ;459
000706  f7fffffe          BL       _Z14ser_sendResultib ; ser_sendResult(int, bool)
00070a  e749              B        |L1.1440|
                  |L1.1804|
00070c  f7fffffe          BL       _Z10cam_getFPSv ; cam_getFPS()
000710  eef60a00          VMOV.F32 s1,#0.50000000        ;464
000714  ee300a20          VADD.F32 s0,s0,s1              ;464
000718  eebc0ac0          VCVT.U32.F32 s0,s0                 ;465
00071c  ee100a10          VMOV     r0,s0                 ;465
000720  4629              MOV      r1,r5                 ;466
000722  f7fffffe          BL       _Z14ser_sendResultib ; ser_sendResult(int, bool)
000726  e73b              B        |L1.1440|
;;;471    
                          ENDP

                  _Z15ser_packetChirpRKhRKjPS_P5Chirp PROC ; ser_packetChirp(const unsigned char&, const unsigned&, const unsigned char*, Chirp*)
;;;472    int32_t ser_packetChirp(const uint8_t &type, const uint32_t &len, const uint8_t *request, Chirp *chirp)
000728  b530              PUSH     {r4,r5,lr}
;;;473    {
00072a  b085              SUB      sp,sp,#0x14
00072c  4615              MOV      r5,r2
00072e  461c              MOV      r4,r3
;;;474    	// handle packet without checksum
;;;475    	ser_packet(type, request, len, false);
000730  780a              LDRB     r2,[r1,#0]
000732  7800              LDRB     r0,[r0,#0]
000734  2300              MOVS     r3,#0
000736  4629              MOV      r1,r5
000738  f7fffffe          BL       _Z10ser_packethPKhhb ; ser_packet(unsigned char, const unsigned char*, unsigned char, bool)
;;;476    	// send result data minus the header data, which we'll bring out explicitly (type, length, no sync)
;;;477    	CRP_RETURN(chirp, UINT8(g_tx[2]) /* type */, UINTS8(g_tx[3] /* len */, g_tx+SER_MIN_PACKET_HEADER) /* raw data */, END);
00073c  4860              LDR      r0,|L1.2240|
00073e  2100              MOVS     r1,#0
000740  6a00              LDR      r0,[r0,#0x20]  ; g_tx
000742  1d02              ADDS     r2,r0,#4
000744  78c3              LDRB     r3,[r0,#3]
000746  e9cd2102          STRD     r2,r1,[sp,#8]
00074a  9104              STR      r1,[sp,#0x10]
00074c  2181              MOVS     r1,#0x81
00074e  9100              STR      r1,[sp,#0]
000750  9301              STR      r3,[sp,#4]
000752  7883              LDRB     r3,[r0,#2]
000754  2201              MOVS     r2,#1
000756  2100              MOVS     r1,#0
000758  4620              MOV      r0,r4
00075a  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
;;;478    	
;;;479    	// return 0 regardless.  Actual result is returned in the g_tx data.
;;;480    	return 0;
;;;481    }
00075e  b005              ADD      sp,sp,#0x14
000760  2000              MOVS     r0,#0                 ;480
000762  bd30              POP      {r4,r5,pc}
;;;482    
                          ENDP

                  _Z10txCallbackPhj PROC ; txCallback(unsigned char*, unsigned)
;;;483    // TX data return mechanism for old serial protocol (v1.0-2.0)
;;;484    uint32_t txCallback(uint8_t *data, uint32_t len)
000764  4a56              LDR      r2,|L1.2240|
;;;485    {
;;;486    	if (g_interface==SER_INTERFACE_LEGO)
000766  7812              LDRB     r2,[r2,#0]  ; g_interface
000768  2a06              CMP      r2,#6
00076a  d005              BEQ      |L1.1912|
;;;487    		return lego_getData(data, len);
;;;488    	else 
;;;489    		return g_blobs->getBlock(data, len);
00076c  460a              MOV      r2,r1
00076e  4601              MOV      r1,r0
000770  4858              LDR      r0,|L1.2260|
000772  6800              LDR      r0,[r0,#0]  ; g_blobs
000774  f7ffbffe          B.W      _ZN5Blobs8getBlockEPhj ; Blobs::getBlock(unsigned char*, unsigned)
                  |L1.1912|
000778  e7fe              B        _Z12lego_getDataPhj ; lego_getData(unsigned char*, unsigned)
;;;490    }
;;;491    
                          ENDP

                  _Z11ser_getBytePh PROC ; ser_getByte(unsigned char*)
;;;492    // TX data return mechanism for new serial protocol (v3.0--)
;;;493    uint8_t ser_getByte(uint8_t *c)
00077a  4a51              LDR      r2,|L1.2240|
;;;494    {
;;;495    	if (g_txReadIndex>=g_txLen)
00077c  8a91              LDRH     r1,[r2,#0x14]  ; g_txReadIndex
00077e  8ad3              LDRH     r3,[r2,#0x16]  ; g_txLen
000780  4299              CMP      r1,r3
000782  d301              BCC      |L1.1928|
;;;496    		return 0;
000784  2000              MOVS     r0,#0
;;;497    	*c = g_tx[g_txReadIndex++];
;;;498    	return 1;
;;;499    }
000786  4770              BX       lr
                  |L1.1928|
000788  1c4b              ADDS     r3,r1,#1              ;497
00078a  8293              STRH     r3,[r2,#0x14]         ;497
00078c  6a12              LDR      r2,[r2,#0x20]         ;497  ; g_tx
00078e  5c51              LDRB     r1,[r2,r1]            ;497
000790  7001              STRB     r1,[r0,#0]            ;497
000792  2001              MOVS     r0,#1                 ;498
000794  4770              BX       lr
;;;500    
                          ENDP

                  _Z14ser_rxCallbackv PROC ; ser_rxCallback()
;;;501    void ser_rxCallback()
000796  e92d41f0          PUSH     {r4-r8,lr}
;;;502    {
00079a  b092              SUB      sp,sp,#0x48
;;;503    	// parse, figure out if the message was intended for us, otherwise pass to currently running program
;;;504    	uint8_t i, a, oldState, buf[SPI2_RECEIVEBUF_SIZE];
;;;505    	uint16_t csCalc;
;;;506    	static uint16_t w, csStream;
;;;507    	static uint8_t lastByte, type, len;
;;;508    	
;;;509    	while(1)
;;;510    	{
;;;511    		oldState = g_state;
;;;512    		switch(g_state)
;;;513    		{	
;;;514    		case 0: // reset 
;;;515    			lastByte = 0xff;  // This is not part of any of the sync word most significant bytes
;;;516    			g_state = 1;
00079c  2701              MOVS     r7,#1
;;;517    		 	break;
;;;518    
;;;519    		case 1:	// sync word
;;;520    			if (g_serial->receive(&a, 1))
;;;521    			{
;;;522    				w = a << 8;
;;;523    				w |= lastByte;
;;;524    				lastByte = a;
;;;525    				g_state = 2;	// compare
;;;526    			}
;;;527    			break;
;;;528    			
;;;529    		case 2:	 // receive data byte(s)
;;;530    			if (w==SER_SYNC_NO_CHECKSUM)
;;;531    			{	// read rest of data
;;;532    				if (g_serial->receiveLen()>=2)
;;;533    				{
;;;534    					g_serial->receive(&type, 1);
;;;535    					g_serial->receive(&len, 1);
;;;536    					
;;;537    					g_state = 3;
;;;538    				}
;;;539    			}
;;;540    			else if (w==SER_SYNC_CHECKSUM)
;;;541    			{
;;;542    				if (g_serial->receiveLen()>=4)
;;;543    				{
;;;544    					g_serial->receive(&type, 1);
;;;545    					g_serial->receive(&len, 1);
;;;546    					g_serial->receive((uint8_t *)&csStream, 2);
;;;547    					
;;;548    					g_state = 4;
;;;549    				}
;;;550    			}
;;;551    			else
;;;552    				g_state = 1;
;;;553    			break;
;;;554    
;;;555    		case 3:
;;;556    			if (len<=SPI2_RECEIVEBUF_SIZE)
;;;557    			{
;;;558    				if (g_serial->receiveLen()>=len)
;;;559    				{
;;;560    					g_serial->receive(buf, len);
;;;561    					g_state = 5;
00079e  f04f0805          MOV      r8,#5
0007a2  2600              MOVS     r6,#0
0007a4  4c46              LDR      r4,|L1.2240|
0007a6  e0a7              B        |L1.2296|
                  |L1.1960|
0007a8  20ff              MOVS     r0,#0xff              ;515
0007aa  72a0              STRB     r0,[r4,#0xa]          ;515
0007ac  70e7              STRB     r7,[r4,#3]            ;516
0007ae  e0a0              B        |L1.2290|
                  |L1.1968|
0007b0  69e0              LDR      r0,[r4,#0x1c]         ;520  ; g_serial
0007b2  2201              MOVS     r2,#1                 ;520
0007b4  6801              LDR      r1,[r0,#0]            ;520
0007b6  688b              LDR      r3,[r1,#8]            ;520
0007b8  a911              ADD      r1,sp,#0x44           ;520
0007ba  4798              BLX      r3                    ;520
0007bc  2800              CMP      r0,#0                 ;520
0007be  d008              BEQ      |L1.2002|
0007c0  f89d0044          LDRB     r0,[sp,#0x44]         ;522
0007c4  0201              LSLS     r1,r0,#8              ;522
0007c6  7aa2              LDRB     r2,[r4,#0xa]          ;523  ; lastByte
0007c8  4311              ORRS     r1,r1,r2              ;523
0007ca  8221              STRH     r1,[r4,#0x10]         ;523
0007cc  72a0              STRB     r0,[r4,#0xa]          ;524
0007ce  2002              MOVS     r0,#2                 ;525
0007d0  70e0              STRB     r0,[r4,#3]            ;525
                  |L1.2002|
0007d2  e08e              B        |L1.2290|
                  |L1.2004|
0007d4  8a20              LDRH     r0,[r4,#0x10]         ;530  ; w
0007d6  f5a04141          SUB      r1,r0,#0xc100         ;530
0007da  39ae              SUBS     r1,r1,#0xae           ;530
0007dc  d005              BEQ      |L1.2026|
0007de  f5a04141          SUB      r1,r0,#0xc100         ;540
0007e2  39af              SUBS     r1,r1,#0xaf           ;540
0007e4  d018              BEQ      |L1.2072|
0007e6  70e7              STRB     r7,[r4,#3]            ;552
0007e8  e083              B        |L1.2290|
                  |L1.2026|
0007ea  69e0              LDR      r0,[r4,#0x1c]         ;532  ; g_serial
0007ec  6801              LDR      r1,[r0,#0]            ;532
0007ee  68c9              LDR      r1,[r1,#0xc]          ;532
0007f0  4788              BLX      r1                    ;532
0007f2  2802              CMP      r0,#2                 ;532
0007f4  db7d              BLT      |L1.2290|
0007f6  69e0              LDR      r0,[r4,#0x1c]         ;534  ; g_serial
0007f8  2201              MOVS     r2,#1                 ;534
0007fa  6801              LDR      r1,[r0,#0]            ;534
0007fc  688b              LDR      r3,[r1,#8]            ;534
0007fe  4930              LDR      r1,|L1.2240|
000800  310b              ADDS     r1,r1,#0xb            ;534
000802  4798              BLX      r3                    ;534
000804  69e0              LDR      r0,[r4,#0x1c]         ;535  ; g_serial
000806  2201              MOVS     r2,#1                 ;535
000808  6801              LDR      r1,[r0,#0]            ;535
00080a  688b              LDR      r3,[r1,#8]            ;535
00080c  492c              LDR      r1,|L1.2240|
00080e  310c              ADDS     r1,r1,#0xc            ;535
000810  4798              BLX      r3                    ;535
000812  2003              MOVS     r0,#3                 ;537
000814  70e0              STRB     r0,[r4,#3]            ;537
000816  e06c              B        |L1.2290|
                  |L1.2072|
000818  69e0              LDR      r0,[r4,#0x1c]         ;542  ; g_serial
00081a  6801              LDR      r1,[r0,#0]            ;542
00081c  68c9              LDR      r1,[r1,#0xc]          ;542
00081e  4788              BLX      r1                    ;542
000820  2804              CMP      r0,#4                 ;542
000822  db66              BLT      |L1.2290|
000824  69e0              LDR      r0,[r4,#0x1c]         ;544  ; g_serial
000826  2201              MOVS     r2,#1                 ;544
000828  6801              LDR      r1,[r0,#0]            ;544
00082a  688b              LDR      r3,[r1,#8]            ;544
00082c  4924              LDR      r1,|L1.2240|
00082e  310b              ADDS     r1,r1,#0xb            ;544
000830  4798              BLX      r3                    ;544
000832  69e0              LDR      r0,[r4,#0x1c]         ;545  ; g_serial
000834  2201              MOVS     r2,#1                 ;545
000836  6801              LDR      r1,[r0,#0]            ;545
000838  688b              LDR      r3,[r1,#8]            ;545
00083a  4921              LDR      r1,|L1.2240|
00083c  310c              ADDS     r1,r1,#0xc            ;545
00083e  4798              BLX      r3                    ;545
000840  69e0              LDR      r0,[r4,#0x1c]         ;546  ; g_serial
000842  2202              MOVS     r2,#2                 ;546
000844  6801              LDR      r1,[r0,#0]            ;546
000846  688b              LDR      r3,[r1,#8]            ;546
000848  491d              LDR      r1,|L1.2240|
00084a  3112              ADDS     r1,r1,#0x12           ;546
00084c  4798              BLX      r3                    ;546
00084e  2004              MOVS     r0,#4                 ;548
000850  70e0              STRB     r0,[r4,#3]            ;548
000852  e04e              B        |L1.2290|
                  |L1.2132|
000854  7b20              LDRB     r0,[r4,#0xc]          ;556  ; len
000856  2840              CMP      r0,#0x40              ;556
000858  d80e              BHI      |L1.2168|
00085a  69e0              LDR      r0,[r4,#0x1c]         ;558  ; g_serial
00085c  6801              LDR      r1,[r0,#0]            ;558
00085e  68c9              LDR      r1,[r1,#0xc]          ;558
000860  4788              BLX      r1                    ;558
000862  7b22              LDRB     r2,[r4,#0xc]          ;558  ; len
000864  4290              CMP      r0,r2                 ;558
000866  db44              BLT      |L1.2290|
000868  69e0              LDR      r0,[r4,#0x1c]         ;560  ; g_serial
00086a  6801              LDR      r1,[r0,#0]            ;560
00086c  688b              LDR      r3,[r1,#8]            ;560
00086e  a901              ADD      r1,sp,#4              ;560
000870  4798              BLX      r3                    ;560
000872  f8848003          STRB     r8,[r4,#3]
000876  e03c              B        |L1.2290|
                  |L1.2168|
;;;562    				}
;;;563    			}
;;;564    			else
;;;565    				g_state = 0;
000878  70e6              STRB     r6,[r4,#3]
00087a  e03a              B        |L1.2290|
                  |L1.2172|
;;;566    			break;
;;;567    			
;;;568    		case 4:
;;;569    			if (len<=SPI2_RECEIVEBUF_SIZE)
00087c  7b20              LDRB     r0,[r4,#0xc]  ; len
00087e  2840              CMP      r0,#0x40
000880  d82c              BHI      |L1.2268|
;;;570    			{
;;;571    				if (g_serial->receiveLen()>=len)
000882  69e0              LDR      r0,[r4,#0x1c]  ; g_serial
000884  6801              LDR      r1,[r0,#0]
000886  68c9              LDR      r1,[r1,#0xc]
000888  4788              BLX      r1
00088a  7b22              LDRB     r2,[r4,#0xc]  ; len
00088c  4290              CMP      r0,r2
00088e  db30              BLT      |L1.2290|
;;;572    				{
;;;573    					g_serial->receive(buf, len);
000890  69e0              LDR      r0,[r4,#0x1c]  ; g_serial
000892  6801              LDR      r1,[r0,#0]
000894  688b              LDR      r3,[r1,#8]
000896  a901              ADD      r1,sp,#4
000898  4798              BLX      r3
;;;574    					for (i=0, csCalc=0; i<len; i++)
00089a  2000              MOVS     r0,#0
00089c  2100              MOVS     r1,#0
00089e  aa01              ADD      r2,sp,#4              ;504
0008a0  7b23              LDRB     r3,[r4,#0xc]          ;556
0008a2  e005              B        |L1.2224|
                  |L1.2212|
;;;575    						csCalc += buf[i];
0008a4  f812c000          LDRB     r12,[r2,r0]
0008a8  4461              ADD      r1,r1,r12
0008aa  b289              UXTH     r1,r1
0008ac  1c40              ADDS     r0,r0,#1              ;574
0008ae  b2c0              UXTB     r0,r0                 ;574
                  |L1.2224|
0008b0  4298              CMP      r0,r3                 ;574
0008b2  d3f7              BCC      |L1.2212|
;;;576    					if (csCalc==csStream)
0008b4  8a60              LDRH     r0,[r4,#0x12]  ; csStream
0008b6  4281              CMP      r1,r0
0008b8  d10e              BNE      |L1.2264|
;;;577    						g_state = 5;
0008ba  f8848003          STRB     r8,[r4,#3]
0008be  e018              B        |L1.2290|
                  |L1.2240|
                          DCD      ||.data||
                  |L1.2244|
                          DCD      ||.bss||
                  |L1.2248|
                          DCD      0x40045000
                  |L1.2252|
0008cc  67656e65          DCB      "general",0
0008d0  72616c00
                  |L1.2260|
                          DCD      g_blobs
                  |L1.2264|
;;;578    					else 
;;;579    						g_state = 0;
0008d8  70e6              STRB     r6,[r4,#3]
0008da  e00a              B        |L1.2290|
                  |L1.2268|
;;;580    				}
;;;581    			}
;;;582    			else
;;;583    				g_state = 0;
0008dc  70e6              STRB     r6,[r4,#3]
0008de  e008              B        |L1.2290|
                  |L1.2272|
;;;584    			break;
;;;585    			
;;;586    		case 5:
;;;587    			ser_packet(type, buf, len, true);
0008e0  2301              MOVS     r3,#1
0008e2  7b22              LDRB     r2,[r4,#0xc]  ; len
0008e4  a901              ADD      r1,sp,#4
0008e6  7ae0              LDRB     r0,[r4,#0xb]  ; type
0008e8  f7fffffe          BL       _Z10ser_packethPKhhb ; ser_packet(unsigned char, const unsigned char*, unsigned char, bool)
;;;588    			g_state = 0;
0008ec  70e6              STRB     r6,[r4,#3]
;;;589    			break;
0008ee  e000              B        |L1.2290|
                  |L1.2288|
;;;590    		
;;;591    		default:
;;;592    			g_state = 0; // try another whole word
0008f0  70e6              STRB     r6,[r4,#3]
                  |L1.2290|
;;;593    			break;
;;;594    		}
;;;595    		if (oldState==g_state)
0008f2  78e0              LDRB     r0,[r4,#3]  ; g_state
0008f4  4285              CMP      r5,r0
0008f6  d00d              BEQ      |L1.2324|
                  |L1.2296|
0008f8  78e5              LDRB     r5,[r4,#3]            ;511  ; g_state
0008fa  2d06              CMP      r5,#6                 ;512
0008fc  d2f8              BCS      |L1.2288|
0008fe  e8dff005          TBB      [pc,r5]               ;512
000902  0807              DCB      0x08,0x07
000904  06050403          DCB      0x06,0x05,0x04,0x03
000908  e7ea              B        |L1.2272|
00090a  e7b7              B        |L1.2172|
00090c  e7a2              B        |L1.2132|
00090e  e761              B        |L1.2004|
000910  e74e              B        |L1.1968|
000912  e749              B        |L1.1960|
                  |L1.2324|
;;;596    			break;
;;;597    	}
;;;598    }
000914  b012              ADD      sp,sp,#0x48
000916  e8bd81f0          POP      {r4-r8,pc}
;;;599    
                          ENDP

                  _Z13ser_newPacketv PROC ; ser_newPacket()
;;;634    
;;;635    bool ser_newPacket()
00091a  498a              LDR      r1,|L1.2884|
;;;636    {
;;;637    	bool result = g_newPacket;
00091c  7908              LDRB     r0,[r1,#4]  ; g_newPacket
;;;638    	g_newPacket = false;
00091e  2200              MOVS     r2,#0
000920  710a              STRB     r2,[r1,#4]
;;;639    	return result;
;;;640    }
000922  4770              BX       lr
;;;641    
                          ENDP

                  _Z16ser_setInterfaceh PROC ; ser_setInterface(unsigned char)
;;;682    
;;;683    int ser_setInterface(uint8_t interface)
000924  e92d47f0          PUSH     {r4-r10,lr}
;;;684    {
000928  4605              MOV      r5,r0
;;;685    	if (interface>SER_INTERFACE_LEGO)
00092a  2d06              CMP      r5,#6
00092c  d903              BLS      |L1.2358|
;;;686    		return -1;
00092e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2354|
;;;687    	
;;;688    	if (g_serial!=NULL)
;;;689    		g_serial->close();
;;;690    
;;;691    	// get g_oldProtocol after we close to prevent race condition with spi interrupt routine
;;;692    	prm_get("Pixy 1.0 compatibility mode", &g_oldProtocol, END);
;;;693    	
;;;694    	// reset variables
;;;695    	g_state = 0;
;;;696    	g_interface = interface;
;;;697    	g_txReadIndex = 0; 
;;;698    	g_txLen = 0; 
;;;699    	g_tx = g_txBuf;
;;;700    	g_brightnessQ.m_valid = false;
;;;701    
;;;702    	switch (interface)
;;;703    	{		    
;;;704    	case SER_INTERFACE_SS_SPI:
;;;705    		if (g_oldProtocol)
;;;706    		{
;;;707    			spi_deinit();
;;;708    			spi2_deinit();
;;;709    			spi_init(txCallback);
;;;710    			g_serial = g_spi;
;;;711    			g_spi->setAutoSlaveSelect(false);
;;;712    		}
;;;713    		else
;;;714    		{
;;;715    			spi_deinit();
;;;716    			spi2_deinit();
;;;717    			spi2_init();
;;;718    			g_serial = g_spi2;
;;;719    			g_spi2->setAutoSlaveSelect(false);
;;;720    		}
;;;721    		break;
;;;722    
;;;723    	case SER_INTERFACE_I2C:     
;;;724    		g_serial = g_i2c0;
;;;725    		g_i2c0->setFlags(false, true);
;;;726    		break;
;;;727    
;;;728    	case SER_INTERFACE_UART:    
;;;729    		g_serial = g_uart0;
;;;730    		break;
;;;731    
;;;732    	case SER_INTERFACE_ADX:      
;;;733    		g_ad->setDirection(true);
;;;734    		g_serial = g_ad;
;;;735    		break;
;;;736    
;;;737    	case SER_INTERFACE_ADY:
;;;738    		g_ad->setDirection(false);
;;;739    		g_serial = g_ad;
;;;740    		break;		
;;;741    
;;;742    	case SER_INTERFACE_LEGO:
;;;743    		g_serial = g_i2c0;
;;;744     		g_i2c0->setSlaveAddr(0x01);
;;;745    		g_i2c0->setFlags(true, false);
;;;746    		g_oldProtocol = true;
;;;747    		break;
;;;748    		
;;;749    	default:
;;;750    	case SER_INTERFACE_ARDUINO_SPI:
;;;751    		if (g_oldProtocol)
;;;752    		{
;;;753    			spi_deinit();
;;;754    			spi2_deinit();
;;;755    			spi_init(txCallback);
;;;756    			g_serial = g_spi;
;;;757    			g_spi->setAutoSlaveSelect(true);
;;;758    		}
;;;759    		else
;;;760    		{
;;;761    			spi_deinit();
;;;762    			spi2_deinit();
;;;763    			spi2_init();
;;;764    			g_serial = g_spi2;
;;;765    			g_spi2->setAutoSlaveSelect(true);
;;;766    		}			
;;;767    		break;
;;;768    	}
;;;769    
;;;770    	g_serial->open();
;;;771    
;;;772    	return 0;
;;;773    }
000932  e8bd87f0          POP      {r4-r10,pc}
                  |L1.2358|
000936  4c83              LDR      r4,|L1.2884|
000938  69e0              LDR      r0,[r4,#0x1c]         ;688  ; g_serial
00093a  b110              CBZ      r0,|L1.2370|
00093c  6801              LDR      r1,[r0,#0]            ;689
00093e  6849              LDR      r1,[r1,#4]            ;689
000940  4788              BLX      r1                    ;689
                  |L1.2370|
000942  4980              LDR      r1,|L1.2884|
000944  2200              MOVS     r2,#0                 ;692
000946  1c89              ADDS     r1,r1,#2              ;692
000948  a07f              ADR      r0,|L1.2888|
00094a  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
00094e  2000              MOVS     r0,#0                 ;695
000950  70e0              STRB     r0,[r4,#3]            ;695
000952  7025              STRB     r5,[r4,#0]            ;696
000954  82a0              STRH     r0,[r4,#0x14]         ;697
000956  82e0              STRH     r0,[r4,#0x16]         ;698
000958  4982              LDR      r1,|L1.2916|
00095a  6221              STR      r1,[r4,#0x20]         ;699  ; g_tx
00095c  4979              LDR      r1,|L1.2884|
00095e  3118              ADDS     r1,r1,#0x18           ;700
000960  7008              STRB     r0,[r1,#0]            ;700
000962  f8df8204          LDR      r8,|L1.2920|
000966  f8df9204          LDR      r9,|L1.2924|
00096a  4f81              LDR      r7,|L1.2928|
00096c  4e81              LDR      r6,|L1.2932|
00096e  2d07              CMP      r5,#7                 ;702
000970  d249              BCS      |L1.2566|
000972  e8dff005          TBB      [pc,r5]               ;702
000976  4804              DCB      0x48,0x04
000978  22292d34          DCB      0x22,0x29,0x2d,0x34
00097c  3b00              DCB      0x3b,0x00
00097e  78a0              LDRB     r0,[r4,#2]            ;705  ; g_oldProtocol
000980  b170              CBZ      r0,|L1.2464|
000982  f7fffffe          BL       _Z10spi_deinitv ; spi_deinit()
000986  f7fffffe          BL       _Z11spi2_deinitv ; spi2_deinit()
00098a  f2af2027          ADR      r0,_Z10txCallbackPhj + 1 ; txCallback(unsigned char*, unsigned)
00098e  f7fffffe          BL       _Z8spi_initPFjPhjE ; spi_init(unsigned(*)(unsigned char*, unsigned))
000992  f8d80000          LDR      r0,[r8,#0]            ;710  ; g_spi
000996  61e0              STR      r0,[r4,#0x1c]         ;710  ; g_serial
000998  2100              MOVS     r1,#0                 ;711
00099a  f7fffffe          BL       _ZN3Spi18setAutoSlaveSelectEb ; Spi::setAutoSlaveSelect(bool)
00099e  e04f              B        |L1.2624|
                  |L1.2464|
0009a0  f7fffffe          BL       _Z10spi_deinitv ; spi_deinit()
0009a4  f7fffffe          BL       _Z11spi2_deinitv ; spi2_deinit()
0009a8  f7fffffe          BL       _Z9spi2_initv ; spi2_init()
0009ac  f8d90000          LDR      r0,[r9,#0]            ;718  ; g_spi2
0009b0  61e0              STR      r0,[r4,#0x1c]         ;718  ; g_serial
0009b2  2100              MOVS     r1,#0                 ;719
0009b4  f7fffffe          BL       _ZN4Spi218setAutoSlaveSelectEb ; Spi2::setAutoSlaveSelect(bool)
0009b8  e042              B        |L1.2624|
0009ba  6838              LDR      r0,[r7,#0]            ;724  ; g_i2c0
0009bc  61e0              STR      r0,[r4,#0x1c]         ;724  ; g_serial
0009be  2201              MOVS     r2,#1                 ;725
0009c0  2100              MOVS     r1,#0                 ;725
0009c2  f7fffffe          BL       _ZN3I2c8setFlagsEbb ; I2c::setFlags(bool, bool)
0009c6  e03b              B        |L1.2624|
0009c8  486b              LDR      r0,|L1.2936|
0009ca  6800              LDR      r0,[r0,#0]            ;729  ; g_uart0
0009cc  61e0              STR      r0,[r4,#0x1c]         ;729  ; g_serial
0009ce  e037              B        |L1.2624|
0009d0  2101              MOVS     r1,#1                 ;733
0009d2  6830              LDR      r0,[r6,#0]            ;733  ; g_ad
0009d4  f7fffffe          BL       _ZN9AnalogDig12setDirectionEb ; AnalogDig::setDirection(bool)
0009d8  6830              LDR      r0,[r6,#0]            ;734  ; g_ad
0009da  61e0              STR      r0,[r4,#0x1c]         ;734  ; g_serial
0009dc  e030              B        |L1.2624|
0009de  2100              MOVS     r1,#0                 ;738
0009e0  6830              LDR      r0,[r6,#0]            ;738  ; g_ad
0009e2  f7fffffe          BL       _ZN9AnalogDig12setDirectionEb ; AnalogDig::setDirection(bool)
0009e6  6830              LDR      r0,[r6,#0]            ;739  ; g_ad
0009e8  61e0              STR      r0,[r4,#0x1c]         ;739  ; g_serial
0009ea  e029              B        |L1.2624|
0009ec  6838              LDR      r0,[r7,#0]            ;743  ; g_i2c0
0009ee  61e0              STR      r0,[r4,#0x1c]         ;743  ; g_serial
0009f0  2101              MOVS     r1,#1                 ;744
0009f2  f7fffffe          BL       _ZN3I2c12setSlaveAddrEh ; I2c::setSlaveAddr(unsigned char)
0009f6  2200              MOVS     r2,#0                 ;745
0009f8  2101              MOVS     r1,#1                 ;745
0009fa  6838              LDR      r0,[r7,#0]            ;745  ; g_i2c0
0009fc  f7fffffe          BL       _ZN3I2c8setFlagsEbb ; I2c::setFlags(bool, bool)
000a00  2001              MOVS     r0,#1                 ;746
000a02  70a0              STRB     r0,[r4,#2]            ;746
000a04  e01c              B        |L1.2624|
                  |L1.2566|
000a06  78a0              LDRB     r0,[r4,#2]            ;751  ; g_oldProtocol
000a08  b170              CBZ      r0,|L1.2600|
000a0a  f7fffffe          BL       _Z10spi_deinitv ; spi_deinit()
000a0e  f7fffffe          BL       _Z11spi2_deinitv ; spi2_deinit()
000a12  f2af20af          ADR      r0,_Z10txCallbackPhj + 1 ; txCallback(unsigned char*, unsigned)
000a16  f7fffffe          BL       _Z8spi_initPFjPhjE ; spi_init(unsigned(*)(unsigned char*, unsigned))
000a1a  f8d80000          LDR      r0,[r8,#0]            ;756  ; g_spi
000a1e  61e0              STR      r0,[r4,#0x1c]         ;756  ; g_serial
000a20  2101              MOVS     r1,#1                 ;757
000a22  f7fffffe          BL       _ZN3Spi18setAutoSlaveSelectEb ; Spi::setAutoSlaveSelect(bool)
000a26  e00b              B        |L1.2624|
                  |L1.2600|
000a28  f7fffffe          BL       _Z10spi_deinitv ; spi_deinit()
000a2c  f7fffffe          BL       _Z11spi2_deinitv ; spi2_deinit()
000a30  f7fffffe          BL       _Z9spi2_initv ; spi2_init()
000a34  f8d90000          LDR      r0,[r9,#0]            ;764  ; g_spi2
000a38  61e0              STR      r0,[r4,#0x1c]         ;764  ; g_serial
000a3a  2101              MOVS     r1,#1                 ;765
000a3c  f7fffffe          BL       _ZN4Spi218setAutoSlaveSelectEb ; Spi2::setAutoSlaveSelect(bool)
                  |L1.2624|
000a40  69e0              LDR      r0,[r4,#0x1c]         ;770  ; g_serial
000a42  6801              LDR      r1,[r0,#0]            ;770
000a44  6809              LDR      r1,[r1,#0]            ;770
000a46  4788              BLX      r1                    ;770
000a48  2000              MOVS     r0,#0                 ;772
000a4a  e772              B        |L1.2354|
;;;774    
                          ENDP

                  _Z14ser_loadParamsv PROC ; ser_loadParams()
;;;653    
;;;654    void ser_loadParams()
000a4c  b530              PUSH     {r4,r5,lr}
;;;655    {
000a4e  b087              SUB      sp,sp,#0x1c
;;;656    #ifndef LEGO
;;;657    	prm_add("Data out port", 0, PRM_PRIORITY_1, 
000a50  2400              MOVS     r4,#0
000a52  2501              MOVS     r5,#1
000a54  e9cd5400          STRD     r5,r4,[sp,#0]
000a58  4b48              LDR      r3,|L1.2940|
000a5a  f44f727a          MOV      r2,#0x3e8
000a5e  4621              MOV      r1,r4
000a60  a047              ADR      r0,|L1.2944|
000a62  9402              STR      r4,[sp,#8]
000a64  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;658    		"Selects the port that's used to output data (default Arduino ICSP SPI) @c Interface @s 0=Arduino_ICSP_SPI @s 1=SPI_with_SS @s 2=I2C @s 3=UART @s 4=analog/digital_x @s 5=analog/digital_y @s 6=LEGO_I2C", UINT8(0), END);
;;;659    	prm_add("I2C address", PRM_FLAG_HEX_FORMAT, PRM_PRIORITY_1-1, 
000a68  2054              MOVS     r0,#0x54
000a6a  e9cd5000          STRD     r5,r0,[sp,#0]
000a6e  4b48              LDR      r3,|L1.2960|
000a70  f24032e7          MOV      r2,#0x3e7
000a74  2110              MOVS     r1,#0x10
000a76  9402              STR      r4,[sp,#8]
000a78  a046              ADR      r0,|L1.2964|
000a7a  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;660    		"@c Interface Sets the I2C address if you are using I2C data out port. (default 0x54)", UINT8(I2C_DEFAULT_SLAVE_ADDR), END);
;;;661    	prm_add("UART baudrate", 0, PRM_PRIORITY_1-2, 
000a7e  f44f4096          MOV      r0,#0x4b00
000a82  e9cd0401          STRD     r0,r4,[sp,#4]
000a86  2104              MOVS     r1,#4
000a88  9100              STR      r1,[sp,#0]
000a8a  4b45              LDR      r3,|L1.2976|
000a8c  f24032e6          MOV      r2,#0x3e6
000a90  2100              MOVS     r1,#0
000a92  a044              ADR      r0,|L1.2980|
000a94  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;662    		"@c Interface Sets the UART baudrate if you are using UART data out port. (default 19200)", UINT32(19200), END);
;;;663    	prm_add("Pixy 1.0 compatibility mode", PRM_FLAG_CHECKBOX, PRM_PRIORITY_1-3, 
000a98  e9cd5400          STRD     r5,r4,[sp,#0]
000a9c  4b45              LDR      r3,|L1.2996|
000a9e  f24032e5          MOV      r2,#0x3e5
000aa2  0269              LSLS     r1,r5,#9
000aa4  a028              ADR      r0,|L1.2888|
000aa6  9402              STR      r4,[sp,#8]
000aa8  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;664    		"@c Interface If this is set, Pixy will return data using the Pixy 1.0 protocol.  This only applies to color connected components program, not other programs. (default false)", UINT8(0), END);
;;;665    
;;;666    	uint8_t interface, addr;
;;;667    	uint32_t baudrate;
;;;668    
;;;669    	prm_get("I2C address", &addr, END);
000aac  2200              MOVS     r2,#0
000aae  a905              ADD      r1,sp,#0x14
000ab0  a038              ADR      r0,|L1.2964|
000ab2  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;670    	g_i2c0->setSlaveAddr(addr);
000ab6  482e              LDR      r0,|L1.2928|
000ab8  f89d1014          LDRB     r1,[sp,#0x14]
000abc  6800              LDR      r0,[r0,#0]  ; g_i2c0
000abe  f7fffffe          BL       _ZN3I2c12setSlaveAddrEh ; I2c::setSlaveAddr(unsigned char)
;;;671    
;;;672    	prm_get("UART baudrate", &baudrate, END);
000ac2  2200              MOVS     r2,#0
000ac4  a904              ADD      r1,sp,#0x10
000ac6  a037              ADR      r0,|L1.2980|
000ac8  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;673    	g_uart0->setBaudrate(baudrate);
000acc  482a              LDR      r0,|L1.2936|
000ace  9904              LDR      r1,[sp,#0x10]
000ad0  6800              LDR      r0,[r0,#0]  ; g_uart0
000ad2  f7fffffe          BL       _ZN4Uart11setBaudrateEj ; Uart::setBaudrate(unsigned)
;;;674    
;;;675    	prm_get("Data out port", &interface, END);
000ad6  2200              MOVS     r2,#0
000ad8  a906              ADD      r1,sp,#0x18
000ada  a029              ADR      r0,|L1.2944|
000adc  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;676    	ser_setInterface(interface);
000ae0  f89d0018          LDRB     r0,[sp,#0x18]
000ae4  f7fffffe          BL       _Z16ser_setInterfaceh ; ser_setInterface(unsigned char)
;;;677    
;;;678    #else
;;;679    	ser_setInterface(SER_INTERFACE_LEGO);
;;;680    #endif
;;;681    }
000ae8  b007              ADD      sp,sp,#0x1c
000aea  bd30              POP      {r4,r5,pc}
;;;682    
                          ENDP

                  _Z8ser_initP5Chirp PROC ; ser_init(Chirp*)
;;;641    
;;;642    int ser_init(Chirp *chirp)
000aec  b510              PUSH     {r4,lr}
;;;643    {
;;;644    	chirp->registerModule(g_module);
000aee  4932              LDR      r1,|L1.3000|
000af0  f7fffffe          BL       _ZN5Chirp14registerModuleEPK10ProcModule ; Chirp::registerModule(const ProcModule*)
;;;645    	i2c_init(txCallback);
000af4  f2af3093          ADR      r0,_Z10txCallbackPhj + 1 ; txCallback(unsigned char*, unsigned)
000af8  f7fffffe          BL       _Z8i2c_initPFjPhjE ; i2c_init(unsigned(*)(unsigned char*, unsigned))
;;;646    	uart_init(txCallback);
000afc  f2af309b          ADR      r0,_Z10txCallbackPhj + 1 ; txCallback(unsigned char*, unsigned)
000b00  f7fffffe          BL       _Z9uart_initPFjPhjE ; uart_init(unsigned(*)(unsigned char*, unsigned))
;;;647    	ad_init();
000b04  f7fffffe          BL       _Z7ad_initv ; ad_init()
;;;648    
;;;649    	ser_loadParams();
000b08  f7fffffe          BL       _Z14ser_loadParamsv ; ser_loadParams()
;;;650    		
;;;651    	return 0;	
000b0c  2000              MOVS     r0,#0
;;;652    }
000b0e  bd10              POP      {r4,pc}
;;;653    
                          ENDP

                  _Z10ser_updatev PROC ; ser_update()
;;;774    
;;;775    void ser_update()
000b10  b510              PUSH     {r4,lr}
;;;776    {
;;;777    	// handled queued commands 
;;;778    	// Brightness change
;;;779    	if (g_brightnessQ.m_valid)
000b12  4c0c              LDR      r4,|L1.2884|
000b14  3418              ADDS     r4,r4,#0x18
000b16  7820              LDRB     r0,[r4,#0]  ; g_brightnessQ
000b18  2800              CMP      r0,#0
000b1a  d004              BEQ      |L1.2854|
;;;780    	{
;;;781    		cam_setBrightness(g_brightnessQ.m_brightness);
000b1c  1c60              ADDS     r0,r4,#1
000b1e  f7fffffe          BL       _Z17cam_setBrightnessRKh ; cam_setBrightness(const unsigned char&)
;;;782    		g_brightnessQ.m_valid = false;
000b22  2000              MOVS     r0,#0
000b24  7020              STRB     r0,[r4,#0]
                  |L1.2854|
;;;783    	}
;;;784    	// update serial channel
;;;785    	ser_getSerial()->update();
000b26  f7fffffe          BL       _Z13ser_getSerialv ; ser_getSerial()
000b2a  6801              LDR      r1,[r0,#0]
000b2c  6909              LDR      r1,[r1,#0x10]
000b2e  e8bd4010          POP      {r4,lr}
000b32  4708              BX       r1
;;;786    }
;;;787    	
                          ENDP

                  _Z12ser_setReadyv PROC ; ser_setReady()
;;;788    void ser_setReady()
000b34  4903              LDR      r1,|L1.2884|
;;;789    {
;;;790    	g_ready = true;
000b36  2001              MOVS     r0,#1
000b38  7148              STRB     r0,[r1,#5]
;;;791    }
000b3a  4770              BX       lr
;;;792    
                          ENDP

                  _Z16ser_getInterfacev PROC ; ser_getInterface()
;;;793    
;;;794    uint8_t ser_getInterface()
000b3c  4801              LDR      r0,|L1.2884|
;;;795    {
;;;796    	return g_interface;
000b3e  7800              LDRB     r0,[r0,#0]  ; g_interface
;;;797    }
000b40  4770              BX       lr
;;;798    
                          ENDP

000b42  0000              DCW      0x0000
                  |L1.2884|
                          DCD      ||.data||
                  |L1.2888|
000b48  50697879          DCB      "Pixy 1.0 compatibility mode",0
000b4c  20312e30
000b50  20636f6d
000b54  70617469
000b58  62696c69
000b5c  7479206d
000b60  6f646500
                  |L1.2916|
                          DCD      ||.bss||
                  |L1.2920|
                          DCD      g_spi
                  |L1.2924|
                          DCD      g_spi2
                  |L1.2928|
                          DCD      g_i2c0
                  |L1.2932|
                          DCD      g_ad
                  |L1.2936|
                          DCD      g_uart0
                  |L1.2940|
                          DCD      ||.conststring||+0xb8
                  |L1.2944|
000b80  44617461          DCB      "Data out port",0
000b84  206f7574
000b88  20706f72
000b8c  7400    
000b8e  00                DCB      0
000b8f  00                DCB      0
                  |L1.2960|
                          DCD      ||.conststring||+0x180
                  |L1.2964|
000b94  49324320          DCB      "I2C address",0
000b98  61646472
000b9c  65737300
                  |L1.2976|
                          DCD      ||.conststring||+0x1d8
                  |L1.2980|
000ba4  55415254          DCB      "UART baudrate",0
000ba8  20626175
000bac  64726174
000bb0  6500    
000bb2  00                DCB      0
000bb3  00                DCB      0
                  |L1.2996|
                          DCD      ||.conststring||+0x234
                  |L1.3000|
                          DCD      ||.constdata||

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_txBuf
                          %        261

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_module
                          DCD      ||.conststring||
                          DCD      _Z15ser_packetChirpRKhRKjPS_P5Chirp ; ser_packetChirp(const unsigned char&, const unsigned&, const unsigned char*, Chirp*)
000008  01810000          DCB      0x01,0x81,0x00,0x00
                          DCD      0x00000000
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0xc
                          DCD      0x00000000
                          DCD      0x00000000
                          %        8
000028  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7365725f          DCB      "ser_packet",0
000004  7061636b
000008  657400  
00000b  00                DCB      0
00000c  53656e64          DCB      "Send program-related sensor data based on request@p typ"
000010  2070726f
000014  6772616d
000018  2d72656c
00001c  61746564
000020  2073656e
000024  736f7220
000028  64617461
00002c  20626173
000030  6564206f
000034  6e207265
000038  71756573
00003c  74407020
000040  747970  
000043  65207265          DCB      "e request type identifier@p data request data@r returns"
000047  71756573
00004b  74207479
00004f  70652069
000053  64656e74
000057  69666965
00005b  72407020
00005f  64617461
000063  20726571
000067  75657374
00006b  20646174
00006f  61407220
000073  72657475
000077  726e73  
00007a  20302072          DCB      " 0 regardless and return data array of bytes based on r"
00007e  65676172
000082  646c6573
000086  7320616e
00008a  64207265
00008e  7475726e
000092  20646174
000096  61206172
00009a  72617920
00009e  6f662062
0000a2  79746573
0000a6  20626173
0000aa  6564206f
0000ae  6e2072  
0000b1  65717565          DCB      "equest",0
0000b5  737400  
0000b8  53656c65          DCB      "Selects the port that's used to output data (default Ar"
0000bc  63747320
0000c0  74686520
0000c4  706f7274
0000c8  20746861
0000cc  74277320
0000d0  75736564
0000d4  20746f20
0000d8  6f757470
0000dc  75742064
0000e0  61746120
0000e4  28646566
0000e8  61756c74
0000ec  204172  
0000ef  6475696e          DCB      "duino ICSP SPI) @c Interface @s 0=Arduino_ICSP_SPI @s 1"
0000f3  6f204943
0000f7  53502053
0000fb  50492920
0000ff  40632049
000103  6e746572
000107  66616365
00010b  20407320
00010f  303d4172
000113  6475696e
000117  6f5f4943
00011b  53505f53
00011f  50492040
000123  732031  
000126  3d535049          DCB      "=SPI_with_SS @s 2=I2C @s 3=UART @s 4=analog/digital_x @"
00012a  5f776974
00012e  685f5353
000132  20407320
000136  323d4932
00013a  43204073
00013e  20333d55
000142  41525420
000146  40732034
00014a  3d616e61
00014e  6c6f672f
000152  64696769
000156  74616c5f
00015a  782040  
00015d  7320353d          DCB      "s 5=analog/digital_y @s 6=LEGO_I2C",0
000161  616e616c
000165  6f672f64
000169  69676974
00016d  616c5f79
000171  20407320
000175  363d4c45
000179  474f5f49
00017d  324300  
000180  40632049          DCB      "@c Interface Sets the I2C address if you are using I2C "
000184  6e746572
000188  66616365
00018c  20536574
000190  73207468
000194  65204932
000198  43206164
00019c  64726573
0001a0  73206966
0001a4  20796f75
0001a8  20617265
0001ac  20757369
0001b0  6e672049
0001b4  324320  
0001b7  64617461          DCB      "data out port. (default 0x54)",0
0001bb  206f7574
0001bf  20706f72
0001c3  742e2028
0001c7  64656661
0001cb  756c7420
0001cf  30783534
0001d3  2900    
0001d5  00                DCB      0
0001d6  00                DCB      0
0001d7  00                DCB      0
0001d8  40632049          DCB      "@c Interface Sets the UART baudrate if you are using UA"
0001dc  6e746572
0001e0  66616365
0001e4  20536574
0001e8  73207468
0001ec  65205541
0001f0  52542062
0001f4  61756472
0001f8  61746520
0001fc  69662079
000200  6f752061
000204  72652075
000208  73696e67
00020c  205541  
00020f  52542064          DCB      "RT data out port. (default 19200)",0
000213  61746120
000217  6f757420
00021b  706f7274
00021f  2e202864
000223  65666175
000227  6c742031
00022b  39323030
00022f  2900    
000231  00                DCB      0
000232  00                DCB      0
000233  00                DCB      0
000234  40632049          DCB      "@c Interface If this is set, Pixy will return data usin"
000238  6e746572
00023c  66616365
000240  20496620
000244  74686973
000248  20697320
00024c  7365742c
000250  20506978
000254  79207769
000258  6c6c2072
00025c  65747572
000260  6e206461
000264  74612075
000268  73696e  
00026b  67207468          DCB      "g the Pixy 1.0 protocol.  This only applies to color co"
00026f  65205069
000273  78792031
000277  2e302070
00027b  726f746f
00027f  636f6c2e
000283  20205468
000287  6973206f
00028b  6e6c7920
00028f  6170706c
000293  69657320
000297  746f2063
00029b  6f6c6f72
00029f  20636f  
0002a2  6e6e6563          DCB      "nnected components program, not other programs. (defaul"
0002a6  74656420
0002aa  636f6d70
0002ae  6f6e656e
0002b2  74732070
0002b6  726f6772
0002ba  616d2c20
0002be  6e6f7420
0002c2  6f746865
0002c6  72207072
0002ca  6f677261
0002ce  6d732e20
0002d2  28646566
0002d6  61756c  
0002d9  74206661          DCB      "t false)",0
0002dd  6c736529
0002e1  00      

                          AREA ||.data||, DATA, ALIGN=2

                  g_interface
000000  ff                DCB      0xff
                  g_angle
000001  00                DCB      0x00
                  g_oldProtocol
000002  00                DCB      0x00
                  g_state
000003  00                DCB      0x00
                  g_newPacket
000004  00                DCB      0x00
                  g_ready
000005  00                DCB      0x00
                  lastLamp
000006  00                DCB      0x00
                  ||ccc||
000007  ff                DCB      0xff
                  line
000008  ff                DCB      0xff
                  video
000009  ff                DCB      0xff
                  lastByte
00000a  00                DCB      0x00
                  type
00000b  00                DCB      0x00
                  len
00000c  0000              DCB      0x00,0x00
                  lastReverse
00000e  ffff              DCW      0xffff
                  w
000010  0000              DCB      0x00,0x00
                  csStream
000012  0000              DCB      0x00,0x00
                  g_txReadIndex
000014  0000              DCB      0x00,0x00
                  g_txLen
000016  0000              DCB      0x00,0x00
                  g_brightnessQ
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  g_serial
                          DCD      0x00000000
                  g_tx
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\serial.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_serial_cpp_888a17e1___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___10_serial_cpp_888a17e1___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_serial_cpp_888a17e1___Z7__REVSHi|
#line 144
|__asm___10_serial_cpp_888a17e1___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
